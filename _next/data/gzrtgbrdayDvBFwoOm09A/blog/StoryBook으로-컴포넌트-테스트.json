{"pageProps":{"slug":"StoryBook으로-컴포넌트-테스트","allBlogData":[{"slug":"코어-자바스크립트-질문-리스트","title":"코어 자바스크립트 질문 리스트","date":"2024년 11월 25일","description":"코어 자바스크립트를 읽고 프론트엔드 개발자로 생각 할 수 있는 기술면접 질문 리스트","thumbnail":"","category":"JavaScript"},{"slug":"자바스크립트-TDD-With-Next-Step","title":"자바스크립트 TDD와 jest 기본 사용법","date":"2023년 7월 23일","description":"자바스크립트 TDD와 Jest 기본 사용 법 및 Next Step 시작","thumbnail":"","category":"JavaScript"},{"slug":"next.js-블로그-회고","title":"Next.js 블로그 첫 번째 회고","date":"2023년 6월 25일","description":"Next.js 블로그 개발 기능 설명 및 첫 번째 회고","thumbnail":"/profile.jpg","category":"Next.js"},{"slug":"점진적과부하-프로젝트-회고","title":"점진적과부하 프로젝트 회고","date":"2023년 5월 22일","description":"점진적과부하 개인 프로젝트 설명 및 회고","thumbnail":"","category":"React"},{"slug":"라이브러리-없이-캘린더-만들기","title":"라이브러리 없이 캘린더 만들기","date":"2023년 5월 15일","description":"라이브러리 없이 Date 메소드 활용 캘린더 만들기","thumbnail":"/assets/images/blog/calendar.png","category":"React"},{"slug":"라이브러리-없이-그래프,-차트-만들기","title":"라이브러리 없이 그래프, 차트 만들기","date":"2023년 5월 08일","description":"라이브러리 없이 SVG 태그를 활용 막대 그래프와 도넛 차트를 만드는 방법","thumbnail":"/assets/images/blog/SVG tag graphs and charts.png","category":"HTML"},{"slug":"Redux와-데이터정규화","title":"Redux와 데이터정규화","date":"2023년 5월 03일","description":"점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화","thumbnail":"","category":"DataBase"},{"slug":"var-let-const-hoisting","title":"var, let, const 특징 및 호이스팅","date":"2023년 4월 25일","description":"var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리","thumbnail":"","category":"JavaScript"},{"slug":"StoryBook으로-컴포넌트-테스트","title":"StoryBook으로 컴포넌트 테스트","date":"2023년 4월 18일","description":"StoryBook을 사용하여 React에서 컴포넌트 테스트를 해보자!","thumbnail":"","category":"Storybook"},{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"},{"slug":"React에서-컴포넌트와-로직-분리하는-방법","title":"React에서 컴포넌트와 로직 분리하는 방법","date":"2023년 4월 03일","description":"React에서 Hook, Utils, Domain으로 컴포넌트와 로직 분리하는 이유와 방법","thumbnail":"","category":"React"}],"fallback":{"@\"Props\",\"StoryBook으로-컴포넌트-테스트\",":{"slug":"StoryBook으로-컴포넌트-테스트","content":"\n## FrontEnd Test\n\n테스트는 학창시절 까지만 해도 단순 시험이였다. 지금도 그렇다. 테스트는 시험이다. 무엇을 위한 시험인가?\n\n개발에서 테스트란 내가 만든 코드가 잘 구현하는지, 오류나 버그가 없는지 등을 파악하기 위해서 테스트 코드를 작성하고 시험해본다. 실제로 사용자에게 서비스가 제공되기 전 거쳐야 하는 과정이다.\n\n사실 이미 테스트를 하면서 개발을 하고 있었다...\n\n```js\nconsole.log()\n```\n\n바로 `console.log()`를 통해 테스트를 하고 있었다. \"이게 무슨 테스트야\" 라고 생각할 수 있지만, 나와 같은 주니어 개발자들은 어떤 기능을 구현하고, 내가 원하는 값이 잘 출력 되는지 알기 위해서 항상 콘솔로그를 출력해 확인하고 있고, 로직이 조금 복잡하다면, 중간 중간에 로그를 출력하면서, 어디서 값이 잘못 되는지 판단하고 있었다.\n\n그렇다고 다른 테스트 방법을 알지 않고, `console.log()`로 코드를 도배하는 것도 문제가 된다.\n\n이제 테스트를 왜 해야하고, 어떤 방법이 있는지 등 알아보겠다.\n\n### 테스트 종류\n\n- End-to-End\n  - 사용자 입장에서 애플리케이션이 잘 동작하는 지 전체적으로 테스트\n- Integration (통합)\n  - 실제 DB, 브라우저 없이 큰 규모의 기능이나 하나의 페이지가 잘 작동하는 지 테스트\n- Unit (단위)\n  - 기능의 개별적인 단위나 하나의 컴포넌트를 테스트\n- Static (정적)\n  - 구문 오류, 나쁜 코드 스타일, 잘못된 API 사용 등을 린팅\n\n### 테스트를 하는 이유\n\n1. 기능적 정확성\n   - 애플리케이션이 예상대로 작동하고 기능적 요구 사항을 총족하는지 확인합니다.\n   - 사용자 경험에 부정적인 영향을 미칠 수 있는 버그나 오류 및 예기치 않은 동작을 포착하는 데 도움이 됩니다.\n2. 사용자 인터페이스 유효성 검사\n   - 레이아웃과 스타일 및 상호 작용과 같은 인터페이스 요소의 유효성 검사를 할 수 있습니다.\n   - 이러한 UI의 테스트는 `Storybook`과 같은 도구를 활용할 수 있습니다.\n   - 흔히 반응형 웹을 만들고, 브라우저와 다양한 장치(폰,테블릿,PC,TV 등)에 맞게 UI가 구현 됐는지 판단하기 위함입니다.\n3. 성능 및 최적화\n   - 애플리케이션이 응답이 빠르고 로드되며 잘 수행되는지 판단하기 위해서 입니다.\n   - 사용자 경험을 저하시킬 수 있는 잠재적인 병목 현상 파악\n   - 비효율적인 코드 또는 리소스를 많이 사용하는 작업을 식벽하는 데 도움이 됩니다.\n   - 테스트를 통해 시간도 측정할 수 있어, 어떤 로직의 연산 시간이 길다면, 알고리즘 측면에서 문제를 해결할 수 있고, 로직을 좀 더 단순화 시켜 성능을 높일 수 있습니다.\n4. 백엔드 서버와 통합\n\n   - API간의 통합 테스트를 통해, 데이터 통신, 인증 등 전반적인 상호 작용 검증하는데 도움이 됩니다.\n   - mocking을 통해 가짜 서버를 만들어 API통신을 테스트할 때 발생하는 문제를 해결할 수 있습니다.\n\n5. CI/CD\n   - 지속적인 배포, 지속적인 통합을 통해 프로덕션에 배포하기 전에 변경 사항을 검증하기 위해 자동화된 테스트를 할 수 있습니다.\n   - 코드의 품질을 유지하고 잘못된 코드 배포를 방지하며 안정적인 애플리케이션을 보장하는데 도움이 됩니다.\n\n### 고려해야하는 것들\n\n1. 프로젝트 규모와 요구 사항 +@일정\n   - 모든 프로젝트의 목적은 완벽이 아니라 완성이기 때문에, 문제가 없고 좋은 코드도 중요하지만, 우선 순위를 정하고 테스트를 진행하는게 좋습니다.\n2. 애플리케이션의 전체적인구성\n   - 모든 곳을 테스트 하기 보단, 필요한 부분에 테스트를 진행하는 것이 좋습니다.\n3. 테스트 도구 설정 난이도\n   - 프로젝트를 진행하는 개발자들이 개발 이외 테스트를 진행함에 따라 문제 없이 진행할 수 있는 어렵지 않고, 충분히 할 수 있는 수준의 테스트 도구로 진행하는게 좋습니다.\n4. 테스트 도구 지향점\n   - jest, cypress, storybook 등의 테스트 도구들을 목적에 맞게 선택해서 사용해야 합니다.\n5. 선행 지식\n   - 개발 진행하기도 어려운데, 테스트 이론, 도구 등 학습을 같이 하면서 개발을 진행하면, 많은 시간이 걸리고, 개발자들도 많은 어려움이 생기니, 프로젝트 시작전 진행할 프로젝트의 테스트를 미리 학습하는 것도 중요한 것 같습니다.\n\n### TDD\n\nTDD (Test Driven Development - 테스트 주도 개발)이란 무엇인가?\n\n많은 개발론 중 하나로 테스트를 기반으로 테스트가 개발을 이끌어 나가는 형태의 개발론입니다.\n\n쉽게 설명하면, 구현보다 테스트를 먼저 작성하고, 테스트가 통과하면 구현을 하는 방식입니다.\n\n크게 3단계로 `실패`, `성공`, `리팩토링` 단계로 이루어져 있습니다.\n\n**1. 실패**\n먼저 실패하는 테스트를 작성합니다. 구현할 기능들을 먼저 테스트로 작성하여, 구현할 기능들을 하나씩 작성하면 됩니다.\n\n**2. 성공**\n두 번째로 성공입니다. 첫 번째 작성했던 실패 테스트를 이제 성공하는 테스트로 만드는 것입니다.\n\n**3. 리팩토링**\n마지막으로 리팩토링 단계 입니다. 구현한 코드에 중복이 있거나, 더 개선할 방법이 있다면 리팩토링을 진행하고, 테스트에 통과하는지 확인합니다. 그리고 다시 첫 번째 단계로 돌아가 계속 진행하면 됩니다.\n\n### TDD 장단점\n\n- 장점\n\n  1. 코드의 품질을 높이고, 버그를 줄이고 유지관리를 더 쉽게 할 수 있도록 도와줍니다.\n  2. 실패한 테스트의 문제를 정확히 찾아내므로 더 빨리 수정할 수 있어 디버깅 속도가 빠릅니다.\n  3. 코드를 구성하는 방법에 대해 생각하게 되고, 보다 모듈화되고 유연한 설계를 통해 전체적인 코드를 개선할 수 있습니다.\n  4. 테스트를 통해 명확한 요구 사항과 문서를 제공함으로써 팀원 구성간의 의사소통이 쉬워 협업에 많은 도움이 됩니다.\n\n- 단점\n  1. TDD의 프로세스를 이해하는데 시간이 걸릴 수 있어, 기능 구현 이외 학습곡선이 필요합니다.\n  2. 기능을 바로 구현하지 않고 테스트 부터 작성하기 때문에 개발 속도가 느려질 수 있습니다.\n  3. 모든 기능이 완벽할 수 없어, 테스트의 우선순위를 정하지 않으면 2번과 마찬가지로 많은 시간이 걸릴 수 있습니다.\n  4. 개선할 기능이 있다면 테스트 역시 개선하기 때문에 추가 노력이 필요합니다.\n\n### Test 도구들\n\n- Jest\n  - 거의 모든 기능과 플랫폼을 지원하는 JavaScript Testing Framework\n- React Testing Library\n  - BDD 방법론에 어울리며 간결하면서도 꼭 필요한 API 지원\n  - Jest와 jsdom기반의 브라우저 DOM Testing\n- Enzyme\n  - React Virtual DOM Testing\n  - 더이상 사용하지 않고 업데이트도 하지 않음\n- Storybook + Chromatic\n  - 컴포넌트 주도의 독립적인 개발 환경 제공\n  - 스냅샷 테스트 지원\n  - 테스트에 용이한 Addon 지원\n- Cypress\n- Jasmine\n- Karma\n- Selenium\n- Puppeteer\n\n## Storybook 이란?\n\n`Storybook`은 UI 테스트를 할 수 있는 도구로 공식문서에 가면 튜토리얼도 있으니 처음은 어렵겠지만 그래도 공부할 수 있다.\n\n`Storybook`을 사용하는 이유는 컴포넌트을 시각적으로 정리하고, 컴포넌트마다 문서화를 할 수 있어, 다른 개발자들과 공유할 때도 편리합니다. 또한 개발자 뿐만 아니라, 디자이너, 기획자 등 비개발 직군의 동료들도 쉽게 UI를 테스트할 수 있어 특히 디자이너와 협업에 좋습니다.\n\n또한 프론트엔드에서 개발을 할 때 아마 대부분 `top-down` 방식으로 개발을 할 것입니다.\n\n> 프론트엔드에서 top-down 방식이란?\n> 위에서 아래로 즉, 페이지 전체에서 작은 요소로 가는 방식을 말한다.\n> 어떠한 페이지를 구현할 때, 페이지 전체를 구현하고, 그안에 헤더, 메인, 푸터 등을 구현하고, 그안에 메뉴 등 큰 단위에서 작은 단위로 구현하는 방식을 말합니다.\n\n### CDD(Component Driven Development)\n\n하지만 스토리북을 사용하면 `CDD(Component Driven Development)` 방식으로 페이지 단위로 UI개발을 하는게 아닌 컴포넌트 부터 만들고 이를 기반으로 페이지를 구성하는 `bottom-up`방식으로 구현할 때 효과적입니다.\n\n컴포넌트 주도개발.. 리액트를 사용하는 장점중 하나입니다.\n\n리액트는 UI를 컴포넌트 단으로 관리를 하고 이를 블럭처럼 쌓는 방식으로 UI를 구현합니다.\n\n저도 흔히 리액트로 개발을 할 떄 `top-down`방식으로 했었기 때문에, `CDD`를 처음 했을 때 많이 어려웠습니다.\n\n내가 구현할 페이지에 사용할 컴포넌트들을 최대한 재사용할 수 있게, 사용할 속성들을 정의하고 어떻게 해야 현재 프로젝트에서 계속 사용할 컴포넌트를 구현하지? 이러한 생각들이 정말 어려웠습니다. 지금도 쉽지는 않아요.\n\n이러한 방식이 어떠한 방향에서는 비효율적일 수 있습니다. `TDD` 처럼 개발자가 빨리 기능을 구현하기도 바쁜데, 일일이다 컴포넌트화 시키고, 재사용성 까지 고려한다는게 쉽지 않기 때문이죠.\n\n## Storybook 예시\n\n![svg](/assets/images/blog/storybook-ex.png)\n\n[스토리북 배포 주소](https://63f86e184232c0d11bdcfbf9-gavtctnezv.chromatic.com/?path=/story/button--default)\n\n위 사진을 보면 오른쪽 상단에 `Button`이 보이고 하단에 `Controls`라는 메뉴에\nName, children, size, color, backgroundColor, fontSize, fontWeight, onClick 이라는 속성안에 라디오 버튼이나, 입력창이 보이는데요.\n\n속성값들을 바꿔보고, 입력창에 다른 것을 입력하면 `Button` UI에 바로 반영이 될겁니다.\n\n개발을 몰라도, 코드 없이 이제 디자이너와 기획자같은 비개발 직군들도 우리가 진행할 프로젝트의 UI를 테스트 할 수 있는 것이죠.\n\n이제 제가 재사용성을 고려해서 버튼을 구현한 것을 `Storybook`으로 구현했던, `Button` 컴포넌트와 `Storybook` 파일의 코드를 보도록 하겠습니다.\n\n```ts\nimport * as S from \"./styles\"\n\ninterface ButtonProps {\n  size: \"auto\" | \"rectangle\"\n  children?: string | React.ReactNode\n  color?: \"black\" | \"white\"\n  backgroundColor?: \"none\" | \"brown\"\n  fontSize?: \"large\" | \"medium\" | \"small\"\n  fontWeight?: \"default\" | \"bold\"\n  onClick?: () => void\n}\n\nconst Button = ({\n  size,\n  children,\n  color = \"black\",\n  backgroundColor = \"none\",\n  fontSize = \"small\",\n  fontWeight = \"default\",\n  ...props\n}: ButtonProps) => {\n  return (\n    <S.Button\n      size={size}\n      color={color}\n      backgroundColor={backgroundColor}\n      fontSize={fontSize}\n      fontWeight={fontWeight}\n      type='button'\n      {...props}\n    >\n      {children}\n    </S.Button>\n  )\n}\n\nexport default Button\n```\n\n먼저 `Button` 컴포넌트 입니다. 재사용성을 고려해서, 현재 프로젝트에서 사용할 스타일 값들을 `props`로 받을 수 있게 구현했습니다.\n\n현재 이 타입들이 정답은 아니고, 제가 구현할 프로젝트에서 사용할 것 같은 속성들을 미리 정의를 해서 어디서든 재사용할 수 있는 `Button` 컴폰너트를 구현할 것 이죠.\n\n```ts\nimport { ComponentStory, ComponentMeta } from \"@storybook/react\"\n\nimport Button from \"./index\"\n\nexport default {\n  title: \"Button\",\n  component: Button,\n} as ComponentMeta<typeof Button>\n\nconst Template: ComponentStory<typeof Button> = (args) => <Button {...args} />\n\nexport const Default = Template.bind({})\n\nDefault.args = {\n  children: \"Button\",\n}\n\nexport const Rectangle = Template.bind({})\n\nRectangle.args = {\n  children: \"장바구니\",\n  size: \"rectangle\",\n  backgroundColor: \"brown\",\n  color: \"white\",\n  fontSize: \"large\",\n  fontWeight: \"bold\",\n}\n```\n\n다음은 `Storybook`으로 구현한 `Button`입니다. `Storybook` 이미지를 보면 `Button` 메뉴 안에 `Default`와`Rectangle`이라는 하위 메뉴가 보이는데 위 처럼 `bind`해서 미리 `Button`안에 속성들을 제가 임의로 설정했고, 배포된 페이지에 속성들을 맘대로 테스트 할 수 있는 것이죠.\n\n스토리북 튜토리얼을 보시면 다 따라할 수 있을겁니다.\n\n## 회고\n\n아직 `CDD`방식으로 개발하는 것에 익숙하지 않고, 많은 노력이 필요할 것 같다.\n\n`Storybook`도 튜토리얼이 4개정도 있어 다 보지는 못했고 숙련이 필요하다.\n\n다른 `Jest`나 `RTK` 등의 테스토도 많이 해보지 않아 많이 부족하다...\n\n공부를 할 수록 계속 배워야 할게 산넘이로 쌓이니.. 개발자는 평생 공부한다는게 쉽지가 않다.\n\n그래도 계속 하다보면, 기술에 익숙해지고, 새로운 기술이나, 버전이 업데이트 되어도, 금방 적응하는 날이 오겠지.\n\n`Storybook`이나 `CDD`를 통해서 디자이너, 기획자 등의 비개발 직군 분들과 좀더 의사소통이 잘될거같았고, 내 생각엔 협업에 효율을 높이기 위해 이러한 방식을 사용하는게 좋은 것 같다.\n\n#### 참고 자료\n\n- https://storybook.js.org/tutorials/intro-to-storybook/react/ko/get-started/\n","title":"StoryBook으로 컴포넌트 테스트","date":"2023년 4월 18일","description":"StoryBook을 사용하여 React에서 컴포넌트 테스트를 해보자!","thumbnail":"","category":"Storybook"}}},"__N_SSG":true}