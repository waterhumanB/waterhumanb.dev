{"pageProps":{"slug":"next.js-블로그-회고","allBlogData":[{"slug":"코어-자바스크립트-질문-리스트","title":"코어 자바스크립트 질문 리스트","date":"2024년 11월 25일","description":"코어 자바스크립트를 읽고 프론트엔드 개발자로 생각 할 수 있는 기술면접 질문 리스트","thumbnail":"","category":"JavaScript"},{"slug":"자바스크립트-TDD-With-Next-Step","title":"자바스크립트 TDD와 jest 기본 사용법","date":"2023년 7월 23일","description":"자바스크립트 TDD와 Jest 기본 사용 법 및 Next Step 시작","thumbnail":"","category":"JavaScript"},{"slug":"next.js-블로그-회고","title":"Next.js 블로그 첫 번째 회고","date":"2023년 6월 25일","description":"Next.js 블로그 개발 기능 설명 및 첫 번째 회고","thumbnail":"/profile.jpg","category":"Next.js"},{"slug":"점진적과부하-프로젝트-회고","title":"점진적과부하 프로젝트 회고","date":"2023년 5월 22일","description":"점진적과부하 개인 프로젝트 설명 및 회고","thumbnail":"","category":"React"},{"slug":"라이브러리-없이-캘린더-만들기","title":"라이브러리 없이 캘린더 만들기","date":"2023년 5월 15일","description":"라이브러리 없이 Date 메소드 활용 캘린더 만들기","thumbnail":"/assets/images/blog/calendar.png","category":"React"},{"slug":"라이브러리-없이-그래프,-차트-만들기","title":"라이브러리 없이 그래프, 차트 만들기","date":"2023년 5월 08일","description":"라이브러리 없이 SVG 태그를 활용 막대 그래프와 도넛 차트를 만드는 방법","thumbnail":"/assets/images/blog/SVG tag graphs and charts.png","category":"HTML"},{"slug":"Redux와-데이터정규화","title":"Redux와 데이터정규화","date":"2023년 5월 03일","description":"점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화","thumbnail":"","category":"DataBase"},{"slug":"var-let-const-hoisting","title":"var, let, const 특징 및 호이스팅","date":"2023년 4월 25일","description":"var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리","thumbnail":"","category":"JavaScript"},{"slug":"StoryBook으로-컴포넌트-테스트","title":"StoryBook으로 컴포넌트 테스트","date":"2023년 4월 18일","description":"StoryBook을 사용하여 React에서 컴포넌트 테스트를 해보자!","thumbnail":"","category":"Storybook"},{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"},{"slug":"React에서-컴포넌트와-로직-분리하는-방법","title":"React에서 컴포넌트와 로직 분리하는 방법","date":"2023년 4월 03일","description":"React에서 Hook, Utils, Domain으로 컴포넌트와 로직 분리하는 이유와 방법","thumbnail":"","category":"React"}],"fallback":{"@\"Props\",\"next.js-블로그-회고\",":{"slug":"next.js-블로그-회고","content":"\n## next.js 블로그\n\n`next.js`로 블로그를 구현 했고 README에 보면 내가 구현한 기능들과 앞으로 구현할 것들을 리스트로 만들었습니다.\n\n처음 시작은 `next.js` 학습을 하려고 `vercel` 페이지에 공식문서와 예제를 보면서 구현을 했고, 이왕 만든거 나의 블로그로 사용하고자 최소한의 모습으로 구현하였습니다.\n\n### 블로그를 시작한 이유\n\n단순 `next.js`에 시작했지만, 개발을 학습하는 방식의 변화를 주기 위해 블로그를 활용하기로 했고, 여러 페이지를 만들어 그 페이지 별로 어떻게 활용할 건지 정하게 되었습니다.\n\n지금 까지 개발 관련 책을 읽고, 프로젝트도 하고, 강의도 듣고 했지만, 정리를 따로 안하다 보니, 배웠던 것을 복습하는 것도 다시 구글링하고 `GitHub` 뒤지고, 조금 번거롭기도 했습니다.\n\n그래서 개발을 공부하고 정리하는 공간과 책이나 강의를 듣고 필기 할곳, 내가 만든 프로젝트를 소개할 곳, 나라는 개발자를 소개할 곳 등 이러한 것들의 필요성을 느끼고 조금씩 블로그를 구현하였습니다.\n\n### Home Page\n\nhttps://waterhumanb-blog.vercel.app\n\n첫 번째로 홈페이지 현재는 간단하게 나의 사진과 간단한 소개글을 적어 두었습니다.\n\n목표는 애플의 아이폰 소개 페이지 처럼 인터렉션한 디자인을 생각하고 있습니다.\n\n디자인 적인 것은 나의 욕심 같은 거라 급하게 생각하지 않고, 천천히 진행중입니다.\n\n### Blog Page\n\nhttps://waterhumanb-blog.vercel.app/blog\n\n블로그 페이지, 개발 관련된 것들의 대한 생각이나 배운 것들을 정리하려고 만든 공간입니다.\n\n확실히 블로그로 정리하고 다시 찾아보고 하면서, 복습도 되고, 새로운 것도 알게되면서 학습과 복습이 같이 할 수 있어 좋은것 같습니다.\n\n정리하는데 시간이 생각보다 많이 걸리지만 그만큼 공부를 한다는 생각이 들어 시간낭비라고 생각하지 않고 오히려 주위 개발자 분들에게 추천을 합니다.\n\n간단하게 기능을 설명하면, `Next.js` 파일 기반으로 `SSG`을 구현할 수 있어, 프로젝트 안에 `mark-up` 문서들을 `html`로 페이지를 만들어 웹에서 볼 수 있습니다.\n\n### Note Page\n\nhttps://waterhumanb-blog.vercel.app/note\n\n블로그 페이지는 배운 것들을 종합적으로 나의 생각과 느낀 것들을 정리하는 공간이라면,\n노트 페이지는 공부한 것을 필기하듯 정리하는 곳입니다.\n\n사이드바에 보면 책으로 배운 것과 강의로 배운 것 두개로 분리를 했습니다.\n\n현재는 바로 바로 정리하기 보단, 일단 책을 한번 편안하게 읽고 시작하는게 좋을 것 같아, 기능만 구현했고, 계속 차근 차근 쌓아갈 예정입니다.\n\n블로그 페이지와 같은 기술로 구현을 했습니다.\n\n### Project Page\n\nhttps://waterhumanb-blog.vercel.app/project\n\n프로젝트 페이지는 앞으로 이력서나 내가 구현한 프로젝트들을 정리한 곳 입니다.\n보이는 사진은 GIF로 만들었고, 데이터는 단순 `TS`파일로 만들어서 데이터를 보여주고 있습니다.\n\n블로그 처럼 글을 보여줄게 아니고 단순하게 다른 링크들을 연결시켜 놓을거라 굳이 `SSG`나 `SSR`로 정보를 받을 필요가 없다고 판단해 이렇게 구현했습니다.\n\n## next.js 구현 기능\n\n### 기술 스택\n\n**기술 스택 :** `Next.js` `TypeScript` `SASS` `SWR`\n\n기본적으로 위와 같은 기술을 사용했고 그 이외 `mark-up`관련 라이브러리 등 사용했고,\n\n스타일은 주로 `styled-component`와 `sass`를 사용하는데 이것도 한번 블로그에 정리를 하려고 합니다.\n\n`SWR`은 빠르고, 가볍게, 재사용 가능한 데이터를 가져오기 위해 사용했다. `React-query`도 있지만 `Vercel`에서 만든 `SWR`이 좀더 잘 맞을거라 생각을 했기 때문에 사용했습니다.\n\n추가로 다른 `css in js`도 공부할 계획입니다.\n\n### 폴더 구조\n\n이번 프로젝트의 폴더 구조와 간단한 설명입니다.\n\n- posts : 마크업 파일\n- public : 이미지\n- src\n  - components : UI 컴포넌트\n    - domain : blog, note 같은 특정한 곳에 사용할 UI 컴포넌트\n    - Layout : 전체 UI 컴포넌트\n  - constants : 상수 값들을 정리\n  - contexts : context api 모음\n  - data : project 데이터 등 다른 데이터들\n  - hooks : 커스텀 hook 모음\n  - lib : blog, note 파일 읽는 등의 로직\n  - pages : 사용자가 보는 페이지\n  - styles : 글로벌 스타일과 재사용 할 스타일\n  - utils : 재사용할 로직\n\n### CSR vs SSR vs SSG\n\n- **CSR(Client-Side Rendering)**\n\n  - 클라이언트(브라우저)인 웹페이지에서 렌더링을 하는 것을 의미한다. 우리가 사용하는 프론트엔드 라이브러리, 프레임워크 삼대장인 `React` `Vue` `Angular` 등이 이러한 방식으로 화면을 보여줍니다.\n  - 동작 방식으로 사용자가 웹 페이지에 들어가면 그 때 `HTML` `CSS` `JavaScript` 파일들을 다운로드 한 뒤에 이용할 수 있는 뷰가 생겨난다. API로 받는 데이터가 있다면 받은 다음 뷰를 구성하기 때문에 처음 로딩 속도가 느리다.\n  - 단점으로 `JavaScript`파일이 커질 수록 어플리케이션 속도가 느려지고, 모든 파일을 다운 받아야 화면을 구성하기 때문에 `SEO`측면에서도 취약한 문제가 있습니다.\n  - 장점으로 처음 페이지가 렌더링 했을 때 모든 파일을 다운로드 했기 떄문에, 페이지이동, 인터렉션 같은 동작이 생겨도 필요한 부분만 추가 다운로드 해서 속도가 굉장히 빠른 것 입니다.\n  - 그래서 사용자와 인터렉션이 많은 애플리케이션은 `CSR` 방식을 사용합니다.\n\n- **SSR(Server-Side Rendering)**\n\n  - 서버에서 미리 페이지를 구성하고 요청을 받으면 즉시 생성해서 반환해 주는 방식입니다. 이러한 방식은 `CSR` 과 다르게 사용자가 웹페이지에 들어가면 미리 만들어둔 화면을 보여주기 때문에 초기 로딩 속도가 빠르다는 장점이 있습니다.\n  - 단점으로 페이지 전환시 깜빡이는 현상이 발생하는데 이는 페이지를 이동할 때 마다 서버에서 새로운 파일을 렌더링해서 발생하는 현상입니다. 그리고 계속 새로운 파일을 로드하기 때문에 클라이언트에서 데이터를 유지할 수 없습니다. `SSG`도 똑같습니다.\n  - 장점으로 최초 로딩속도가 빠르고, `CSR` 과 다르게 서버에서 페이지를 생성해 주기 때문에, 검색엔진은 완성된 `HTML`문서를 수집할 수 있어 `SEO`에 최적화에 용이합니다.\n\n- **SSG(Static Site Generation)**\n  - `SSR`과 비슷하지만 조금 다른 점은 프로젝트를 빌드 할 때 페이지를 미리 만들어 렌더링 하는 방식입니다. `SSR`과 비슷한 것은 페이지를 미리 만들어서 요청이 있을 때 제공하는 방식이 비슷하지만, `SSR`은 API 요청을 했을 때 페이지를 만들어 보내주지만, `SSG`는 빌드할 때 만들어 놓는 다는 점입니다.\n  - 그리고 빌드 시 페이지가 만들어져 있어, 요청시에 바로바로 클라이언트에게 페이지를 제공하기 때문에 렌더링 속도가 빠르고, 완성된 페이지는 `SEO` 최적화에 용이합니다.\n  - 이러한 특성이 블로그 같은 정보성 페이지 등 정적인 데이터를 보여주는 사이트에 적합한 것이죠.\n\n`CSR` `SSR` `SSG`를 표로 한번 비교해서 보겠습니다.\n\n|                  | **CSR**                                                         | **SSR**                                     | **SSG**                                                     |\n| ---------------- | --------------------------------------------------------------- | ------------------------------------------- | ----------------------------------------------------------- |\n| 렌더링 방식      | 클라이언트에서 렌더링된 빈 HTML 파일                            | 서버는 각 요청에 대해 HTML을 생성합니다     | 빌드 시 생성된 미리 렌더링된 HTML 파일                      |\n| 초기 로드 시간   | 빠르지만 가져오기 및 렌더링으로 인해 초기 로드가 느려질 수 있음 | 서버 처리로 인해 느려질 수 있음             | 미리 렌더링된 HTML을 제공할 준비가 되었기 때문에 빠름       |\n| SEO 친화성       | 동적 콘텐츠를 인덱싱하려면 검색 엔진에 추가 기술이 필요         | 완전히 렌더링된 HTML이 제공되므로 좋음      | 완전히 렌더링된 HTML이 제공되므로 좋음                      |\n| 동적 업데이트    | 클라이언트 측에서 실시간 업데이트 지원                          | 각 요청에 대한 실시간 업데이트 지원         | 동적 콘텐츠에 대한 재검증 또는 클라이언트 측 렌더링 필요    |\n| 서버 로드        | 렌더링이 클라이언트 측에서 처리되므로 더 낮음                   | 서버가 각 요청을 렌더링함에 따라 더 높음    | 미리 렌더링된 HTML은 정적 파일로 제공될 수 있으므로 더 낮음 |\n| 개발 복잡성      | 렌더링 및 데이터 가져오기는 클라이언트측 책임이므로 낮음        | 서버측 로직 필요로 보통                     | 빌드 시 데이터 가져오기 및 구성 필요로 보통                 |\n| 성능 (후속 로드) | 필요한 클라이언트측 렌더링 및 데이터 가져오기의 양에 따라 다름  | 필요한 클라이언트측 렌더링의 양에 따라 다름 | HTML이 미리 렌더링되고 캐시되므로 빠름                      |\n\n### Next.js\n\n`Next.js`는 위에 3가지 방법을 모두 사용할 수 있습니다.\n\n일단 `Next.js`는 `React`를 기반으로한 프레임워크이기 때문에 `CSR` 동작을 할 수 있고,\n\n`SSG`는 기본적으로 빌드할 때 자동으로 생성이 되고 추가로 생성도 할 수 있습니다.\n\n`SSR`도 마찬가지로 서버에서 데이터를 받고 싶을 때 사용할 수 있습니다.\n\n`CSR`은 `React`의 `Hook`을 활용해서 사용하면 되고, `SSG`와 `SSR`은 `Next.js`의 내장함수를 사용해서 구현해야한다.\n\n```ts\nexport const getStaticPaths: GetStaticPaths = () => {\n  // slug에 대한 가능한 값의 목록을 반환합니다.\n  const paths = getAllPostSlugs()\n  return {\n    paths,\n    fallback: false,\n  }\n}\n\nexport const getStaticProps: GetStaticProps = async ({ params }: any) => {\n  // params.slug를 사용하여 블로그 게시물에 필요한 데이터를 가져옵니다.\n  const postData = await getPostData(params.slug)\n  return {\n    props: {\n      slug: postData.slug,\n      fallback: {\n        [unstableSerialize([\"Props\", postData.slug])]: postData,\n      },\n    },\n  }\n}\n```\n\n- **SSG**\n  - 위에 코드는 현재 블로그 페이지에서 게시글을 `SSG`로 받아오는 방법입니다.\n  - `getStaticProps`를 통해 정적 페이지를 생성해서 해당 컴포넌트에서 `Props`로 받아 UI를 만들 수 있습니다.\n  - 또한 `getStaticPaths`를 통해 정적으로 생성할 경로 목록을 지정해서 해당 경로를 정적으로 사전 렌더링을 해서, 보다 빠르게 페이지를 받아서 볼 수 있습니다.\n\n```ts\nimport type { InferGetServerSidePropsType, GetServerSideProps } from \"next\"\n\ntype Repo = {\n  name: string\n  stargazers_count: number\n}\n\nexport const getServerSideProps: GetServerSideProps<{\n  repo: Repo\n}> = async () => {\n  const res = await fetch(\"https://api.github.com/repos/vercel/next.js\")\n  const repo = await res.json()\n  return { props: { repo } }\n}\n\nexport default function Page({\n  repo,\n}: InferGetServerSidePropsType<typeof getServerSideProps>) {\n  return repo.stargazers_count\n}\n```\n\n- **SSR**\n  - `getServerSideProps`를 사용하여 서버로 부터 데이터를 받아 `Props`로 컴포넌트에서 사용할 수 있습니다.\n  - `SSG`는 배포시 미리 정적 페이지를 만들지만 `SSR`은 요청할 때 데이터를 반환하기 때문에 속도 측면에서 차이가 생깁니다.\n  - 이번 블로그에서는 모두 `SSG`로 구현했기 때문에 코드는 공식문서에서 가져왔습니다.\n\n[Next.js 에서 데이터를 가져오는 방법](https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props)\n\n### SEO (Search Engine Optimization)\n\n검색엔진 최적화라는 의미로 구글이나 네이버 같은 포털사이트에서 나의 블로그, 사이트 등 내가 만든 웹 페이지가 검색시 최상단에서 노출하는 것을 말합니다.\n\n`SEO` 최적화 방법은 여러개가 있습니다. 프론트엔드 개발자가 알아야할 최적화 방법만 소개하겠습니다.\n\n- **시멘틱 태그 (Semantic Tag)**\n  - 무분별한 `div`의 사용으로 웹문서에서 원하는 정보를 찾기 힘들어져 `HTML` 구조를 설계하는데 있어 각 위치별로 태그에 의미를 부여해서 사이트의 구조를 파악하기 용이하게 만들어진 태그들 입니다.\n  - 사이트를 만들 때 그 목적에 맞게 `tag`들로 구조를 잡으면 검색 엔진이 사이트를 보다 빨리 파악할 수 있어 검색 결과 노출에 유리합니다.\n\n```ts\nconst META_DATA = {\n  title: \"Blog\",\n  description:\n    \"개발하면서 느낀점, 생각 등을 공유하거나 복습하고 싶은 기술들을정리하는 곳입니다.\",\n  openGraph: {\n    type: \"website\",\n    locale: \"ko_KR\",\n    url: \"waterhumanb-blog.vercel.app/blog\",\n    title:\n      \"개발하면서 느낀점, 생각 등을 공유하거나 복습하고 싶은 기술들을정리하는 곳입니다.\",\n    site_name: \"waterhumanb.dev\",\n    images: [\n      {\n        url: \"../../public/thumbnail.png\",\n        width: 285,\n        height: 167,\n        alt: \"이미지\",\n      },\n    ],\n  },\n}\n```\n\n- **Meta Tag 활용**\n  - 시멘틱 태그로 웹문서의 구조를 파악할 수 있게 했다면, 이제 웹문서의 정보를 제공해야 한다. 우리는 `meta tag`를 활용해서 사이트의 다양한 정보들을 제공할 수 있습니다.\n  - 위 코드는 블로그의 메인 페이지에서 사용하고 있는 `meta tag`에 활용할 데이터 입니다.\n  - `next.js`에서 제공하는 `next-seo`를 활용하면 이 웹사이트 전체 기본으로 `meta tag`를 설정하고 페이지 별로 다른 `meta tag`를 설정해서, 페이지 마다 다른 정보를 제공해주고 있습니다.\n- **빠른 렌더링**\n  - 렌더링 되는 속도가 빨라야합니다. 한군인은 빨리빨리라는 말처럼, 웹페이지가 로딩되는 속도에 따라 방문자들이 조금만 느려도 바로 나가버리기 때문에, `SEO`측면에서 페이지 로딩 속도가 느리면 좋은 사이트로 판단하지 않습니다.\n  - 렌더링 속도를 빠르게 하려면 `CSR`같은 방식보다는 `SSG`방식이 속도가 더 빠르기에 유리하고, `CSR`은 앞에 말했던, 빈 `HTML`문서만 있기 때문에 검색봇이 사이트를 판단하지 못하기 때문에 `SEO`측면에서 어떻게 보면 최악이죠. 그렇기 때문에, 미리 웹문서를 만들어 화면에 보여주는 방식이 속도 측면과 `SEO` 측면에서 효과적입니다.\n  - 그리고 사이트의 크기를 줄여야 합니다. 아무래도 메모리를 많이 잡아 먹으면 그만큼 속도가 느려지고, 그만큼 페이지를 늦게 로딩하겠죠? 큰 영상과 이미지등의 크기를 줄이는 방법이 제일 효과적이고 `LightHouse` 등 도구를 활용하면 페이지의 로딩 속도가 느린 이유들을 알 수 있어 활용하면 좋습니다.\n- **그 밖의 참고할 것**\n  - 페이지가 선정적이거나 불법적인 내용이면 당연히 안좋겠죠.\n  - 사이트 목적에 따른 도메인주소도 도움이 된다고 합니다.\n  - `sitemap` 같은 파일도 미리 만들어 내 사이트를 검색 봇이 빨리 파악 할 수 있게 도와줍니다.\n  - `next.js`에서는 `next/img` 같은 내장함수로 이미지를 최적화 하는 방법도 있습니다.\n\n### 앞으로 구현 할 기능\n\nTOC라는 기능도 만들고 README에 있는 기능들도 구현할 예정들이다.\n\n사이트가 단순하게 구현했는데, 좀더 인터렉티브한 웹으로 구성하고 싶고,\n\n다른 블로그들을 봤을 떄 이러한 기능들이 재미있는 것들을 구현하고 계획입니다.\n\n추가 페이지는 저를 소개하는 페이지와 저의 이력서 관련 페이지도 만들어\n\n블로그 겸 저의 포토폴리오, 이력서를 구현하는게 제 최종 목표입니다.\n\n## 회고\n\n아직 next.js의 다양한 기능들도 많이 사용하지 않았다. next.js를 활용한 다른 프로젝트도 하지 않았고,\n\n시도해 볼만한게 많을 것 같다. 몇몇 강의를 보면 next.js를 활용한 풀스텍 개발이라는 강의들도 보이고\n\n다양한 프로젝트에 시도할 수 있을 것 같다.\n\nSEO는 내가 디지털 마케팅을 독학 했을 때 공부했던 것들이 이렇게 도움될줄 몰랐다.\n\nSSR, CSR, SSG는 완전히 이해를 했다고 못하지만, 어느정도 이해가 되었고, 조금 자리를 잡은 것 같다.\n\n블로그에 기록하는 이유는 언제든지 내가 정리한 것들을 보기 위해서 정리를 하고 있으니 기억이 안나고 헷갈리면\n\n다시 보면 된다.\n\n앞으로 계획 한것들 열심히 하자 블로그도 열심히 해보자!\n\n#### 참고 자료\n\n- https://swr.vercel.app/ko\n- https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props\n","title":"Next.js 블로그 첫 번째 회고","date":"2023년 6월 25일","description":"Next.js 블로그 개발 기능 설명 및 첫 번째 회고","thumbnail":"/profile.jpg","category":"Next.js"}}},"__N_SSG":true}