{"pageProps":{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","allBlogData":[{"slug":"코어-자바스크립트-질문-리스트","title":"코어 자바스크립트 질문 리스트","date":"2024년 11월 25일","description":"코어 자바스크립트를 읽고 프론트엔드 개발자로 생각 할 수 있는 기술면접 질문 리스트","thumbnail":"","category":"JavaScript"},{"slug":"자바스크립트-TDD-With-Next-Step","title":"자바스크립트 TDD와 jest 기본 사용법","date":"2023년 7월 23일","description":"자바스크립트 TDD와 Jest 기본 사용 법 및 Next Step 시작","thumbnail":"","category":"JavaScript"},{"slug":"next.js-블로그-회고","title":"Next.js 블로그 첫 번째 회고","date":"2023년 6월 25일","description":"Next.js 블로그 개발 기능 설명 및 첫 번째 회고","thumbnail":"/profile.jpg","category":"Next.js"},{"slug":"점진적과부하-프로젝트-회고","title":"점진적과부하 프로젝트 회고","date":"2023년 5월 22일","description":"점진적과부하 개인 프로젝트 설명 및 회고","thumbnail":"","category":"React"},{"slug":"라이브러리-없이-캘린더-만들기","title":"라이브러리 없이 캘린더 만들기","date":"2023년 5월 15일","description":"라이브러리 없이 Date 메소드 활용 캘린더 만들기","thumbnail":"/assets/images/blog/calendar.png","category":"React"},{"slug":"라이브러리-없이-그래프,-차트-만들기","title":"라이브러리 없이 그래프, 차트 만들기","date":"2023년 5월 08일","description":"라이브러리 없이 SVG 태그를 활용 막대 그래프와 도넛 차트를 만드는 방법","thumbnail":"/assets/images/blog/SVG tag graphs and charts.png","category":"HTML"},{"slug":"Redux와-데이터정규화","title":"Redux와 데이터정규화","date":"2023년 5월 03일","description":"점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화","thumbnail":"","category":"DataBase"},{"slug":"var-let-const-hoisting","title":"var, let, const 특징 및 호이스팅","date":"2023년 4월 25일","description":"var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리","thumbnail":"","category":"JavaScript"},{"slug":"StoryBook으로-컴포넌트-테스트","title":"StoryBook으로 컴포넌트 테스트","date":"2023년 4월 18일","description":"StoryBook을 사용하여 React에서 컴포넌트 테스트를 해보자!","thumbnail":"","category":"Storybook"},{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"},{"slug":"React에서-컴포넌트와-로직-분리하는-방법","title":"React에서 컴포넌트와 로직 분리하는 방법","date":"2023년 4월 03일","description":"React에서 Hook, Utils, Domain으로 컴포넌트와 로직 분리하는 이유와 방법","thumbnail":"","category":"React"}],"fallback":{"@\"Props\",\"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점\",":{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","content":"\n## Controlled Component\n\n> HTML에서 `<input>`, `<textarea>`, `<select>`와 같은 폼 엘리먼트는 일반적으로 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트합니다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트됩니다.\n> 우리는 React state를 “신뢰 가능한 단일 출처 (single source of truth)“로 만들어 두 요소를 결합할 수 있습니다. 그러면 폼을 렌더링하는 React 컴포넌트는 폼에 발생하는 사용자 입력값을 제어합니다. 이러한 방식으로 React에 의해 값이 제어되는 입력 폼 엘리먼트를 “제어 컴포넌트 (controlled component)“라고 합니다.\n>\n> 출처 : https://ko.legacy.reactjs.org/docs/forms.html#controlled-components\n\n공식문서에서 위와 같은 설명을 해주고 있습니다. 쉽게 말해 입력폼에 `state`를 통해 관리를 하고 제어하는 것이 `Controlled Component`입니다.\n\n아마도 흔히 `React`로 로그인, 회원가입, 게시글, 댓글 등 입력할 수 있는 컴포넌트를 구현할 때, `<input>`를 활용해서 `useState`를 통해 값을 입력받고, 유효성 검사, 서버에 전달 등 기능을 구현합니다.\n\n## UnControlled Component\n\n비제어 컴포넌트란 무엇인가?\n\n자료를 찾아보니 전통적인 방식이라고 많이 표현하는 것을 보았는데, `React`같은 라이브러리나 `Next.js`같은 프레임워크 등이 등장하기 전에는 `JavaScript`로 `DOM`을 직접 조작하여 우리가 원하는 기능을 만들었습니다.\n\n`React`에서는 `ref`를 이용해서 직접 `DOM`을 조작할 수 있습니다.\n\n쉽게 말해 `React`에서 `ref`로 컴포넌트를 조작하면 비제어 컴포넌트가 되는 것이죠.\n\n## 제어 컴포넌트와 비제어 컴포넌트의 차이점\n\n그렇다면 제어 컴포넌트와 비제어 컴포넌트의 차이점은 무엇일까?\n\n제어가 가능하고 제어가 불가능 하다는 의미가 무엇일까?\n\n위에서 말했던 제어 컴포넌트는 `state` 상태값을 가지고 컴포넌트를 제어합니다.\n\n`React`에서 렌더링이 되는 조건을 보면, 부모 요소가 변경될때, 상태값이 변경될 때 입니다.\n\n`State`가 변경되면서 해당 컴포넌트의 데이터와 `State`의 데이터가 동기화 되면서, 웹에서도 사용자가 어떤 행동을 하는지 알 수 있습니다.\n\n반대로 `ref`를 통해 직접 `DOM`을 조작한다면, 웹은 사용자가 어떤 동작을 하는지 알 수 없습니다. 만약 `ID`를 입력 받는 `<Input>` 컴포넌트를 사용해서 `<Button`을 누르면 데이터가 전송된다고 했을 때, 버튼을 누르기 전까지 웹에서는 사용자가 어떤 값을 입력했는지 알 수 없는 것이죠.\n\n그렇기 때문에 비제어 컴포넌트라고 합니다.\n\n## 제어 컴포넌트와 비제어 컴포넌트의 장단점\n\n### 장점\n\n**제어 컴포넌트**\n제어 컴포넌트는 주로 유효성 검사를 할 때 사용합니다.\n우리가 이메일, ID, 비밀번호 등 사용자가 입력한 값들을 즉각적으로 판단하고 사용자에게 보여주려면, 사용자가 입력한 값과 `State`값을 동기화 시켜 바로바로 검사를 해주는 것이 좋겠죠.\n\n**비제어 컴포넌트**\n비제어 컴포넌트는 제어 컴포넌트 처럼 입력한 값을 즉각적으로 판단하지 않고, 필요할 때 입력값을 추출할 경우에 사용합니다. ID나 비밀번호 등 중요한 정보들은 즉각적으로 유효성검사를 해서 사용자에게 바로바로 피드백을 줘야하지만, 만약 자기소개같은 정보는 굳이 데이터와 상태를 동기화 시켜 입력받을 필요는 없기 때문입니다.\n\n### 단점\n\n**제어 컴포넌트**\n제어 컴포넌트의 단점은 단어 하나하나 입력할 때 마다 값이 갱신되어 불필요하게 렌더링이 되어 성능 측면에 좋지 않고, 만약 바로바로 `API`호출이 된다면, 자원 낭비가 되겠죠.\n\n```ts\nconst Test = () => {\n  const [id, setId] = useState(\"\")\n  console.log(id)\n  return (\n    <div>\n      </input onChange={setId}>\n    </div>\n  )\n}\n```\n\n이렇게 `<Input>`으로 `waterHumanB`를 입력한다고 할 때 `console.log`를 보면\n\n```ts\nw\nwa\nwat\nwate\nwater\nwaterH\nwaterHu\nwaterHum\nwaterHuma\nwaterHuman\nwaterHumanB\n```\n\n이런 식으로 모든 값을 받아오게 되면서 계속 계속 렌더링이 될겁니다.\n\n이를 방지하기 위해서는 `Throttle`과 `Debounce`를 사용하면 됩니다.\n\n> 쓰로틀`Throttle` : 연속된 이벤트를 호출하지 않고 일정 시간 간격으로 이벤트가 최대한 한번만 호출하게 합니다.\n> ex) 무한 스크롤 UI구현 같은 이벤트에 사용합니다.\n> 디바운싱`Debounce` : 연속된 이벤트를 호출하지 않고 일정 시간이 경과한 이후 한번만 호출 합니다.\n> ex) 입력 필드 자동완성, 버튼 중복 클릭 방지 처리에 유용합니다.\n\n**비제어 컴포넌트**\n\n비제어 컴포넌트의 단점은 제어 컴포넌트의 장점의 반대라고 생각하면 됩니다.\n입력된 데이터를 상태값과 동기화 되지 않기 때문에, 유효성 검사 같은 기능은 구현할 수 없겠죠.\n\n입력 받는 값을 알 수 없으니, 테스트나 디버깅에도 어렵습니다.\n\n제어 컴포넌트와 비제어 컴포넌트를 적절히 사용해서, 단점들을 보안해서 사용하면 될거 같아요.\n\n마지막으로 표를 보면 간단하게 정리를 했습니다.\n\n| 특징                           | 비제어 | 제어 |\n| ------------------------------ | ------ | ---- |\n| 일회성 값 검색(예: 제출 시)    | ✅     | ✅   |\n| 제출 시 유효성 검사            | ✅     | ✅   |\n| 즉각적인 필드 유효성 검사      | ❌     | ✅   |\n| 조건부 제출 버튼 비활성화      | ❌     | ✅   |\n| 입력 형식 적용                 | ❌     | ✅   |\n| 하나의 데이터에 대한 여러 입력 | ❌     | ✅   |\n| 동적 입력                      | ❌     | ✅   |\n\n그리고 무조건 제어, 비제어 나누지 않고, 언제든지 비제어 컴포넌트를 제어 컴포넌트로 마이그레이션 가능합니다.\n\n뭐든지 상황에 맞게 기능을 구현하는게 정답인거 같네요.\n\n## 회고\n\n처음 제어, 비제어 컴포넌트라는 용어를 들었을 때 아무생각도 들지 않았고 단순히 `state`사용과 `ref`사용 이정도로 끝냈었다.\n\n생각해 보면, 사용자의 정보를 얻고 유효성 검사를 했을 때 무조건 `state`를 사용해서 관리를 했고, 무한 스크롤 같은 UI를 구현할 때는 `ref`로 구현을 했었다.\n\n무의식 적으로 이렇게 하는게 편하고, 그렇게 했으니까? 이런 생각들로 구현을 했었는데,\n\n이제는 좀 더 내가 왜 이렇게 구현했는지, 의미를 알 수 있고, `<Input>`으로 입력된 데이터를 처리할 때, 어떤 방식이 좀 더 효율적인지 알게 되었다.\n\n아직도 부족하지만, 나의 코드가 어떤 의미이고, 왜 이렇게 했는지 조금은 설명이 더 할 수 있을 것 같다.\n\n#### 참고 자료\n\n- https://ko.legacy.reactjs.org/docs/forms.html#controlled-components\n- https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/\n","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"}}},"__N_SSG":true}