<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@site"/><meta name="twitter:creator" content="@handle"/><link rel="canonical" href="https://waterhumanb.github.io"/><title>Redux와 데이터정규화</title><meta name="robots" content="index,follow"/><meta name="description" content="점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화"/><meta property="og:title" content="Redux와 데이터정규화"/><meta property="og:description" content="점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화"/><meta property="og:url" content="https://waterhumanb.github.io/blog/Redux와-데이터정규화"/><meta property="og:type" content="website"/><meta property="og:image" content=""/><meta property="og:image:alt" content="이미지"/><meta property="og:image:width" content="285"/><meta property="og:image:height" content="167"/><meta property="og:locale" content="ko_KR"/><meta property="og:site_name" content="waterhumanb.dev"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="UBbrn6uYlvgqUuPSNz6397TblWqGKuSHzwf_e2jijxk"/><meta name="naver-site-verification" content="5b4676776e4bf7929cd196996b0da94331749653"/><link rel="preload" href="/_next/static/css/d8bed1e24432d094.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d8bed1e24432d094.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/ae9d48751daeccdb.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/ae9d48751daeccdb.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-26292afa9ac61214.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-e14092e0d084b50d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-de761518420b1770.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-144889350ae033c1.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/664-4376551f6398547f.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/675-a22d097d5bbbe350.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/972-cbebcee7e82a5949.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-ef6dc5c9b42e3c93.js" defer="" crossorigin=""></script><script src="/_next/static/HstNFDYMYBk7yzRF4J0tt/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/HstNFDYMYBk7yzRF4J0tt/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><header class="header_header___ROMs"><div class="nav_nav__8z_BE"><div><a href="/"><div class="">Home</div></a></div><nav class="nav_navLinks__n71QG"><a href="/blog/"><div class="nav_active__ZBV7z">Blog</div></a><a href="/note/"><div class="">Note</div></a></nav></div></header><main class="layout_container__12fKi"><div><div class="postLayout_postContainer__sy9uX"><aside class="sideBar_sideBarContainer___AvzN"><div class="sideBar_sideBar__xUXBW"><div>Blog<!-- --> Menu</div><a class="undefined " href="/blog/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8/">코어 자바스크립트 질문 리스트</a><a class="undefined " href="/blog/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-TDD-With-Next-Step/">자바스크립트 TDD와 jest 기본 사용법</a><a class="undefined " href="/blog/next.js-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%9A%8C%EA%B3%A0">Next.js 블로그 첫 번째 회고</a><a class="undefined " href="/blog/%EC%A0%90%EC%A7%84%EC%A0%81%EA%B3%BC%EB%B6%80%ED%95%98-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0/">점진적과부하 프로젝트 회고</a><a class="undefined " href="/blog/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%97%86%EC%9D%B4-%EC%BA%98%EB%A6%B0%EB%8D%94-%EB%A7%8C%EB%93%A4%EA%B8%B0/">라이브러리 없이 캘린더 만들기</a><a class="undefined " href="/blog/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%97%86%EC%9D%B4-%EA%B7%B8%EB%9E%98%ED%94%84,-%EC%B0%A8%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/">라이브러리 없이 그래프, 차트 만들기</a><a class="undefined sideBar_hovered__eF0xN" href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/">Redux와 데이터정규화</a><a class="undefined " href="/blog/var-let-const-hoisting/">var, let, const 특징 및 호이스팅</a><a class="undefined " href="/blog/StoryBook%EC%9C%BC%EB%A1%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8/">StoryBook으로 컴포넌트 테스트</a><a class="undefined " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/">Controlled 컴포넌트와 UnControlled 컴포넌트 차이점</a><a class="undefined " href="/blog/React%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%A1%9C%EC%A7%81-%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/">React에서 컴포넌트와 로직 분리하는 방법</a></div></aside><div class="postLayout_postBox__4BFa4"><header class="title_container__fhpAF"><h1>Redux와 데이터정규화</h1><span>2023년 5월 03일</span></header><article class="section_container__KqTMH"><article class="content_container__Kx6HO"><h2 id="데이터-정규화란">데이터 정규화란?</h2>
<p>모든 필드와 레코드가 논리적으로 구성되어 중복을 방지할 뿐만 아니라, 관계형 데이터베이스를 보다 효율적으로 사용하도록 하는 방법입니다.</p>
<p>라고 설명하고 있지만, 설명만 봐서는 이해가 조금 어려웠다. 핵심은 데이터베이스를 효율적으로 관리 하는 게 목적인 거 같다.</p>
<h2 id="redux와-데이터-정규화와-관계">Redux와 데이터 정규화와 관계</h2>
<p>점진적 과부하 프로젝트를 진행할 때 프론트에서 상태관리를 하기 때문에 좀 더 효율적으로 관리하고 싶었다.</p>
<p>지금 까지 생각해보면, 백엔드가 있을 때는 API문서를 통해 데이터를 어떤 식으로 주고받을지 정해서 했지만, 혼자 프로젝트를 했을 때 그때마다 필요한 데이터를 만들고, 조합해서 사용했었다.</p>
<p><a href="https://lunit.gitbook.io/redux-in-korean/recipes/structuringreducers/normalizingstateshape" target="_blank" rel="noopener noreferrer">리덕스에서 데이터 정규화 예시</a></p>
<p>위 링크에 들어가 보면 Redux 공식문서에서 상태 정규화를 통해 상태관리를 하는 방법을 알려준다.</p>
<p>내가 점진적 과부하 프로젝트에서 Redux를 통해 데이터 정규화를 진행했던 가장 큰 이유다. 공식문서에서 자세히 알려주고 있어, 궁합이 잘 맞을 거라고 생각했고, 학습하기에도 수월했다.</p>
<p>데이터 정규화를 통해 내가 사용할 상태들을 어떻게 관리할지 만들었고, 그렇게 프로젝트를 진행했다.</p>
<p>Redux에서 데이터 정규화를 통해 상태관리를 보다 효율적이게 할 수 있다고 알려주고 있다.</p>
<p>간단하게 설명하면, 만약 블로그의 상태관리를 한다고 해보면, <code>post</code>라는 상태값과 그안에 <code>byId</code>안에 <code>post1</code>, <code>post2</code> 이런 식으로 데이터를 만들고 <code>allIds</code> 안에 <code>post</code>들을 배열로 관리하면서 <code>byId</code>에 객체 체이닝을 통해 값을 확인하지 않고, <code>allIds</code>를 통해 바로 접근할 수 있다.</p>
<p>아래 예시를 보자 참고로 아래 예시는 Redux 공식문서 데이터 정규화 부분에서 가져왔다.</p>
<pre><pre node="[object Object]" style="background:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%);font-family:&quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0.5em 0;overflow:auto;border-radius:0.3em"><code class="language-js" style="white-space:pre;background:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%);font-family:&quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;direction:ltr;text-align:left;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token literal-property" style="color:hsl(5, 74%, 59%)">posts</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">{</span><span>
</span><span>        </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">byId</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">{</span><span>
</span><span>            </span><span class="token string-property" style="color:hsl(5, 74%, 59%)">&quot;post1&quot;</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">{</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">id</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;post1&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">author</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;user1&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">body</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;......&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">comments</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">[</span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;comment1&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;comment2&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">]</span><span>
</span><span>            </span><span class="token" style="color:hsl(230, 8%, 24%)">}</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span>
</span><span>            </span><span class="token string-property" style="color:hsl(5, 74%, 59%)">&quot;post2&quot;</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">{</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">id</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;post2&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">author</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;user2&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">body</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;......&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span>
</span><span>                </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">comments</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">[</span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;comment3&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;comment4&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;comment5&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">]</span><span>
</span><span>            </span><span class="token" style="color:hsl(230, 8%, 24%)">}</span><span>
</span><span>        </span><span class="token" style="color:hsl(230, 8%, 24%)">}</span><span>
</span><span>        </span><span class="token literal-property" style="color:hsl(5, 74%, 59%)">allIds</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">:</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">[</span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;post1&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span> </span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;post2&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">]</span><span>
</span><span>    </span><span class="token" style="color:hsl(230, 8%, 24%)">}</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span></code></pre></pre>
<p>위처럼 <code>allIds</code> 통해 <code>post</code> id에 접근해서 게시물을 삭제, 추가, 개수 확인 등의 기능을 만들 수 있고, 그리고 <code>user</code>와 <code>comment</code>역시 위와 같은 형태로 만들어 똑같이 관리할 수 있다.</p>
<p><code>posts</code>라는 데이터 안에 모든 값이 계속 중첩되는 게 아니라, 각각 따로 만들어서 사용하면, 데이터가 깊게 중첩이 되지 않아 관리하기 편하다는 장점이 있었다.</p>
<h2 id="redux에서-데이터-정규화의-장점">Redux에서 데이터 정규화의 장점</h2>
<p>위에서 말했던 장점이 외도 많은 장점이 있다.</p>
<ol>
<li>각 항목이 하나의 위치만 정의해서, 상태값이 업데이트돼도 여러 위치를 바꾸지 않아도 되고</li>
<li>리듀서로직이 깊게 중첩된 데이터를 관리하지 않아 보다 편리하게 데이터를 관리할 수 있고</li>
<li>모든 데이터는 ID가 있어, 어떤 데이터를 찾거나 업데이트할 때 쉽게 찾을 수 있고</li>
<li>데이터 타입이 분리되어 있어, 어떠한 데이터를 변경하거나 업데이트할 때 필요한 곳만 상태가 변경되고 그곳만 리렌더링 되면서 불필요한 리렌더링을 막을 수 있다. 이는 만약 상태값이 모두 중첩이 된 데이터라면 작은 부분만 바꿔도 전체가 렌더링 되기 때문에, 속도, 메모리 등의 측면에서 효율적이다.</li>
</ol>
<p>내가 프로젝트를 하면서 가장 장점이라고 느낀 것은 2번과 3번이다.</p>
<p>프론트에서만 데이터를 관리해서 데이터 자체를 다루는데 복잡하긴 했지만, 리듀서의 로직은 간단하게 구현할 수 있었고, 데이터를 수정, 삭제, 추가, 업데이트 등의 기능을 구현할 때도 ID로 관리가 가능했다.</p>
<p>4번은 약간 <code>React</code>에서 리렌더링이 되는 조건들을 생각해보면 <code>state</code>가 변경되고, 새로운 <code>props</code>가 들어고, 기존 <code>props</code>가 업데이트되고, 부모 컴포넌트가 리렌더링 될 때 이 정도 인거 같은데, <code>Redux</code>를 통해 전역으로 상태관리를 하고 데이터가 중첩이 많이 된 상태를 페이지에서 UI로 보여준다고 했을 때, 중첩된 데이터에서 조금이라도 변경이 되면 전체를 리렌더링 하는 상황이 발생한다.</p>
<p>이것을 방지하기 위해 모든 데이터가 분리되고 ID만으로 찾을 수 있고, 페이지 안에 여러 UI의 데이터가 분리되어 어떠한 상태가 변경돼도 그 UI만 리렌더링되는게 장점인 거 같다.</p>
<h2 id="redux에서-데이터-정규화의-단점">Redux에서 데이터 정규화의 단점</h2>
<ol>
<li>코드의 복잡성이 증가한다.</li>
<li>데이터 정규화를 구현하면서 구조, 관계 등을 고려하면서 개발 시간이 늘어난다.</li>
<li>위와 비슷하게 중첩되는 중첩되는 되어 과잉 정규화가 생겨 복잡성과 개발 시간이 늘어난다.</li>
</ol>
<p>위 3가지 단점들은 구글링을 통해 조금 알아본 것들이다.</p>
<p>1번 공감한다. 처음 정규화를 통해 프로젝트를 했을 때, 리듀서 로직은 비교적 간단했지만, 데이터를 다루는 데 있어서 어려움이 많았다...</p>
<p><strong>백엔드가 있었으면, 요청하고 받은 데이터로 편리하게 할 수 있었겠다</strong> 라는 생각을 많이 했었다.</p>
<p>2번 처음 상태를 정규화하고 프로젝트를 진행하면서 몇 번이고 데이터 구조를 변경하면서 기능도 수정하고 좀 더 괜찮은 구조가 생각나면 다시 적용하고, 변경하고 생각보다 구조 변경을 많이 했었다. 한번 구조를 잡으면 이대로 구현을 할 생각이었지만, 데이터를 이렇게 하면 좀 더 UI를 만들 때 편하겠다. 이런 생각들이 개발 시간을 늘어나게 했었다.</p>
<p>1번, 2번을 겪으면서 3번의 문제처럼 절충안을 찾아야 했다. 데이터 정규화를 통해 모든 데이트를 분리할까 고민도 했지만, 데이터의 중첩이 많지 않으면 크게 복잡하지 않게 UI와 기능들을 구현할 수 있다고 생각했고, 그렇게 프로젝트도 마무미를 할 수 있었다.</p>
<h2 id="회고">회고</h2>
<p><code>Redux</code>와 데이터정규화를 알게 된 계기는 프로젝트를 할 때마다 상황에 맞춰 상태 데이터를 만들어 관리했었고, 상태 데이터를 규칙적이게 관리를 하고 싶었던게 시작이었다.</p>
<p>프론트엔드 개발자는 UI만 만드는 개발자라고 생각해서 시작했지만, 지금은 많은 상태관리 툴이 생기고, 효율적으로 상태 데이터를 관리하는 게 좀 더 취중이 높아진 거 같다.</p>
<p>데이터정규화를 통해 처음으로 혼자 데이터 구조를 잡고 진행했었고, 나름 체계적으로 진행했다고 생각한다.</p>
<p>데이터 구조에 관심이 생긴 계기가 되었고, 몇 번의 프로젝트를 통해 데이터 정규화 방법도 좀 더 잘할 수 있으면 좋겠고, 다른 상태관리 툴과 다른 데이터 구조 및 관리 방법도 공부해야겠다.</p>
<h4 id="참고-자료">참고 자료</h4>
<ul>
<li><a href="https://lunit.gitbook.io/redux-in-korean/recipes/structuringreducers/normalizingstateshape" target="_blank" rel="noopener noreferrer">https://lunit.gitbook.io/redux-in-korean/recipes/structuringreducers/normalizingstateshape</a></li>
</ul></article></article><div class="postLayout_comment__mmog_"><section></section></div></div><aside class="TOC_tocContainer__xG3B8"><div class="TOC_toc__bb4qM"><div>Table of Content</div><a class="TOC_mainHead__UCw15 " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80">데이터 정규화란?</a><a class="TOC_mainHead__UCw15 " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/#redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EA%B7%9C%ED%99%94%EC%99%80-%EA%B4%80%EA%B3%84">Redux와 데이터 정규화와 관계</a><a class="TOC_mainHead__UCw15 " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/#redux%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EA%B7%9C%ED%99%94%EC%9D%98-%EC%9E%A5%EC%A0%90">Redux에서 데이터 정규화의 장점</a><a class="TOC_mainHead__UCw15 " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/#redux%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EA%B7%9C%ED%99%94%EC%9D%98-%EB%8B%A8%EC%A0%90">Redux에서 데이터 정규화의 단점</a><a class="TOC_mainHead__UCw15 " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/#%ED%9A%8C%EA%B3%A0">회고</a><a class="TOC_subHead__zXtIP " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C">참고 자료</a></div></aside></div></div></main><footer class="footer_footerContainer__M6t1B"><div class="footer_copy__6DxmK">Copyright © 2024 WaterHumanB</div><div class="footer_devBox__UPiww"><a class="footer_dev__wo6Qp" target="_blank" href="https://github.com/waterhumanB/waterhumanb.dev"><div>WaterHumanB.dev</div></a></div></footer></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"slug":"Redux와-데이터정규화","allBlogData":[{"slug":"코어-자바스크립트-질문-리스트","title":"코어 자바스크립트 질문 리스트","date":"2024년 11월 25일","description":"코어 자바스크립트를 읽고 프론트엔드 개발자로 생각 할 수 있는 기술면접 질문 리스트","thumbnail":"","category":"JavaScript"},{"slug":"자바스크립트-TDD-With-Next-Step","title":"자바스크립트 TDD와 jest 기본 사용법","date":"2023년 7월 23일","description":"자바스크립트 TDD와 Jest 기본 사용 법 및 Next Step 시작","thumbnail":"","category":"JavaScript"},{"slug":"next.js-블로그-회고","title":"Next.js 블로그 첫 번째 회고","date":"2023년 6월 25일","description":"Next.js 블로그 개발 기능 설명 및 첫 번째 회고","thumbnail":"/profile.jpg","category":"Next.js"},{"slug":"점진적과부하-프로젝트-회고","title":"점진적과부하 프로젝트 회고","date":"2023년 5월 22일","description":"점진적과부하 개인 프로젝트 설명 및 회고","thumbnail":"","category":"React"},{"slug":"라이브러리-없이-캘린더-만들기","title":"라이브러리 없이 캘린더 만들기","date":"2023년 5월 15일","description":"라이브러리 없이 Date 메소드 활용 캘린더 만들기","thumbnail":"/assets/images/blog/calendar.png","category":"React"},{"slug":"라이브러리-없이-그래프,-차트-만들기","title":"라이브러리 없이 그래프, 차트 만들기","date":"2023년 5월 08일","description":"라이브러리 없이 SVG 태그를 활용 막대 그래프와 도넛 차트를 만드는 방법","thumbnail":"/assets/images/blog/SVG tag graphs and charts.png","category":"HTML"},{"slug":"Redux와-데이터정규화","title":"Redux와 데이터정규화","date":"2023년 5월 03일","description":"점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화","thumbnail":"","category":"DataBase"},{"slug":"var-let-const-hoisting","title":"var, let, const 특징 및 호이스팅","date":"2023년 4월 25일","description":"var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리","thumbnail":"","category":"JavaScript"},{"slug":"StoryBook으로-컴포넌트-테스트","title":"StoryBook으로 컴포넌트 테스트","date":"2023년 4월 18일","description":"StoryBook을 사용하여 React에서 컴포넌트 테스트를 해보자!","thumbnail":"","category":"Storybook"},{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"},{"slug":"React에서-컴포넌트와-로직-분리하는-방법","title":"React에서 컴포넌트와 로직 분리하는 방법","date":"2023년 4월 03일","description":"React에서 Hook, Utils, Domain으로 컴포넌트와 로직 분리하는 이유와 방법","thumbnail":"","category":"React"}],"fallback":{"@\"Props\",\"Redux와-데이터정규화\",":{"slug":"Redux와-데이터정규화","content":"\n## 데이터 정규화란?\n\n모든 필드와 레코드가 논리적으로 구성되어 중복을 방지할 뿐만 아니라, 관계형 데이터베이스를 보다 효율적으로 사용하도록 하는 방법입니다.\n\n라고 설명하고 있지만, 설명만 봐서는 이해가 조금 어려웠다. 핵심은 데이터베이스를 효율적으로 관리 하는 게 목적인 거 같다.\n\n## Redux와 데이터 정규화와 관계\n\n점진적 과부하 프로젝트를 진행할 때 프론트에서 상태관리를 하기 때문에 좀 더 효율적으로 관리하고 싶었다.\n\n지금 까지 생각해보면, 백엔드가 있을 때는 API문서를 통해 데이터를 어떤 식으로 주고받을지 정해서 했지만, 혼자 프로젝트를 했을 때 그때마다 필요한 데이터를 만들고, 조합해서 사용했었다.\n\n[리덕스에서 데이터 정규화 예시](https://lunit.gitbook.io/redux-in-korean/recipes/structuringreducers/normalizingstateshape)\n\n위 링크에 들어가 보면 Redux 공식문서에서 상태 정규화를 통해 상태관리를 하는 방법을 알려준다.\n\n내가 점진적 과부하 프로젝트에서 Redux를 통해 데이터 정규화를 진행했던 가장 큰 이유다. 공식문서에서 자세히 알려주고 있어, 궁합이 잘 맞을 거라고 생각했고, 학습하기에도 수월했다.\n\n데이터 정규화를 통해 내가 사용할 상태들을 어떻게 관리할지 만들었고, 그렇게 프로젝트를 진행했다.\n\nRedux에서 데이터 정규화를 통해 상태관리를 보다 효율적이게 할 수 있다고 알려주고 있다.\n\n간단하게 설명하면, 만약 블로그의 상태관리를 한다고 해보면, `post`라는 상태값과 그안에 `byId`안에 `post1`, `post2` 이런 식으로 데이터를 만들고 `allIds` 안에 `post`들을 배열로 관리하면서 `byId`에 객체 체이닝을 통해 값을 확인하지 않고, `allIds`를 통해 바로 접근할 수 있다.\n\n아래 예시를 보자 참고로 아래 예시는 Redux 공식문서 데이터 정규화 부분에서 가져왔다.\n\n```js\nposts : {\n        byId : {\n            \"post1\" : {\n                id : \"post1\",\n                author : \"user1\",\n                body : \"......\",\n                comments : [\"comment1\", \"comment2\"]\n            },\n            \"post2\" : {\n                id : \"post2\",\n                author : \"user2\",\n                body : \"......\",\n                comments : [\"comment3\", \"comment4\", \"comment5\"]\n            }\n        }\n        allIds : [\"post1\", \"post2\"]\n    },\n```\n\n위처럼 `allIds` 통해 `post` id에 접근해서 게시물을 삭제, 추가, 개수 확인 등의 기능을 만들 수 있고, 그리고 `user`와 `comment`역시 위와 같은 형태로 만들어 똑같이 관리할 수 있다.\n\n`posts`라는 데이터 안에 모든 값이 계속 중첩되는 게 아니라, 각각 따로 만들어서 사용하면, 데이터가 깊게 중첩이 되지 않아 관리하기 편하다는 장점이 있었다.\n\n## Redux에서 데이터 정규화의 장점\n\n위에서 말했던 장점이 외도 많은 장점이 있다.\n\n1. 각 항목이 하나의 위치만 정의해서, 상태값이 업데이트돼도 여러 위치를 바꾸지 않아도 되고\n2. 리듀서로직이 깊게 중첩된 데이터를 관리하지 않아 보다 편리하게 데이터를 관리할 수 있고\n3. 모든 데이터는 ID가 있어, 어떤 데이터를 찾거나 업데이트할 때 쉽게 찾을 수 있고\n4. 데이터 타입이 분리되어 있어, 어떠한 데이터를 변경하거나 업데이트할 때 필요한 곳만 상태가 변경되고 그곳만 리렌더링 되면서 불필요한 리렌더링을 막을 수 있다. 이는 만약 상태값이 모두 중첩이 된 데이터라면 작은 부분만 바꿔도 전체가 렌더링 되기 때문에, 속도, 메모리 등의 측면에서 효율적이다.\n\n내가 프로젝트를 하면서 가장 장점이라고 느낀 것은 2번과 3번이다.\n\n프론트에서만 데이터를 관리해서 데이터 자체를 다루는데 복잡하긴 했지만, 리듀서의 로직은 간단하게 구현할 수 있었고, 데이터를 수정, 삭제, 추가, 업데이트 등의 기능을 구현할 때도 ID로 관리가 가능했다.\n\n4번은 약간 `React`에서 리렌더링이 되는 조건들을 생각해보면 `state`가 변경되고, 새로운 `props`가 들어고, 기존 `props`가 업데이트되고, 부모 컴포넌트가 리렌더링 될 때 이 정도 인거 같은데, `Redux`를 통해 전역으로 상태관리를 하고 데이터가 중첩이 많이 된 상태를 페이지에서 UI로 보여준다고 했을 때, 중첩된 데이터에서 조금이라도 변경이 되면 전체를 리렌더링 하는 상황이 발생한다.\n\n이것을 방지하기 위해 모든 데이터가 분리되고 ID만으로 찾을 수 있고, 페이지 안에 여러 UI의 데이터가 분리되어 어떠한 상태가 변경돼도 그 UI만 리렌더링되는게 장점인 거 같다.\n\n## Redux에서 데이터 정규화의 단점\n\n1. 코드의 복잡성이 증가한다.\n2. 데이터 정규화를 구현하면서 구조, 관계 등을 고려하면서 개발 시간이 늘어난다.\n3. 위와 비슷하게 중첩되는 중첩되는 되어 과잉 정규화가 생겨 복잡성과 개발 시간이 늘어난다.\n\n위 3가지 단점들은 구글링을 통해 조금 알아본 것들이다.\n\n1번 공감한다. 처음 정규화를 통해 프로젝트를 했을 때, 리듀서 로직은 비교적 간단했지만, 데이터를 다루는 데 있어서 어려움이 많았다...\n\n**백엔드가 있었으면, 요청하고 받은 데이터로 편리하게 할 수 있었겠다** 라는 생각을 많이 했었다.\n\n2번 처음 상태를 정규화하고 프로젝트를 진행하면서 몇 번이고 데이터 구조를 변경하면서 기능도 수정하고 좀 더 괜찮은 구조가 생각나면 다시 적용하고, 변경하고 생각보다 구조 변경을 많이 했었다. 한번 구조를 잡으면 이대로 구현을 할 생각이었지만, 데이터를 이렇게 하면 좀 더 UI를 만들 때 편하겠다. 이런 생각들이 개발 시간을 늘어나게 했었다.\n\n1번, 2번을 겪으면서 3번의 문제처럼 절충안을 찾아야 했다. 데이터 정규화를 통해 모든 데이트를 분리할까 고민도 했지만, 데이터의 중첩이 많지 않으면 크게 복잡하지 않게 UI와 기능들을 구현할 수 있다고 생각했고, 그렇게 프로젝트도 마무미를 할 수 있었다.\n\n## 회고\n\n`Redux`와 데이터정규화를 알게 된 계기는 프로젝트를 할 때마다 상황에 맞춰 상태 데이터를 만들어 관리했었고, 상태 데이터를 규칙적이게 관리를 하고 싶었던게 시작이었다.\n\n프론트엔드 개발자는 UI만 만드는 개발자라고 생각해서 시작했지만, 지금은 많은 상태관리 툴이 생기고, 효율적으로 상태 데이터를 관리하는 게 좀 더 취중이 높아진 거 같다.\n\n데이터정규화를 통해 처음으로 혼자 데이터 구조를 잡고 진행했었고, 나름 체계적으로 진행했다고 생각한다.\n\n데이터 구조에 관심이 생긴 계기가 되었고, 몇 번의 프로젝트를 통해 데이터 정규화 방법도 좀 더 잘할 수 있으면 좋겠고, 다른 상태관리 툴과 다른 데이터 구조 및 관리 방법도 공부해야겠다.\n\n#### 참고 자료\n\n- https://lunit.gitbook.io/redux-in-korean/recipes/structuringreducers/normalizingstateshape\n","title":"Redux와 데이터정규화","date":"2023년 5월 03일","description":"점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화","thumbnail":"","category":"DataBase"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"Redux와-데이터정규화"},"buildId":"HstNFDYMYBk7yzRF4J0tt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>