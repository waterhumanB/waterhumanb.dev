<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@site"/><meta name="twitter:creator" content="@handle"/><link rel="canonical" href="https://waterhumanb.github.io/waterhumanb.dev"/><title>var, let, const 특징 및 호이스팅</title><meta name="robots" content="index,follow"/><meta name="description" content="var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리"/><meta property="og:title" content="var, let, const 특징 및 호이스팅"/><meta property="og:description" content="var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리"/><meta property="og:url" content="https://waterhumanb.github.io/waterhumanb.dev/blog/var-let-const-hoisting"/><meta property="og:type" content="website"/><meta property="og:image" content=""/><meta property="og:image:alt" content="이미지"/><meta property="og:image:width" content="285"/><meta property="og:image:height" content="167"/><meta property="og:locale" content="ko_KR"/><meta property="og:site_name" content="waterhumanb.dev"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="UBbrn6uYlvgqUuPSNz6397TblWqGKuSHzwf_e2jijxk"/><meta name="naver-site-verification" content="5b4676776e4bf7929cd196996b0da94331749653"/><link rel="preload" href="/_next/static/css/d8bed1e24432d094.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d8bed1e24432d094.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/ae9d48751daeccdb.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/ae9d48751daeccdb.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-26292afa9ac61214.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-e14092e0d084b50d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-de761518420b1770.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-cc949ee6526e1040.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/664-4376551f6398547f.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/675-a22d097d5bbbe350.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/972-cbebcee7e82a5949.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-115f68c48d8c80a2.js" defer="" crossorigin=""></script><script src="/_next/static/xSQOQ32O3HBNjY_uIzKPY/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/xSQOQ32O3HBNjY_uIzKPY/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><header class="header_header___ROMs"><div class="nav_nav__8z_BE"><div><a href="/"><div class="">Home</div></a></div><nav class="nav_navLinks__n71QG"><a href="/blog/"><div class="nav_active__ZBV7z">Blog</div></a><a href="/note/"><div class="">Note</div></a></nav></div></header><main class="layout_container__12fKi"><div><div class="postLayout_postContainer__sy9uX"><aside class="sideBar_sideBarContainer___AvzN"><div class="sideBar_sideBar__xUXBW"><div>Blog<!-- --> Menu</div><a class="undefined " href="/blog/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8/">코어 자바스크립트 질문 리스트</a><a class="undefined " href="/blog/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-TDD-With-Next-Step/">자바스크립트 TDD와 jest 기본 사용법</a><a class="undefined " href="/blog/next.js-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%9A%8C%EA%B3%A0">Next.js 블로그 첫 번째 회고</a><a class="undefined " href="/blog/%EC%A0%90%EC%A7%84%EC%A0%81%EA%B3%BC%EB%B6%80%ED%95%98-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0/">점진적과부하 프로젝트 회고</a><a class="undefined " href="/blog/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%97%86%EC%9D%B4-%EC%BA%98%EB%A6%B0%EB%8D%94-%EB%A7%8C%EB%93%A4%EA%B8%B0/">라이브러리 없이 캘린더 만들기</a><a class="undefined " href="/blog/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%97%86%EC%9D%B4-%EA%B7%B8%EB%9E%98%ED%94%84,-%EC%B0%A8%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/">라이브러리 없이 그래프, 차트 만들기</a><a class="undefined " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/">Redux와 데이터정규화</a><a class="undefined sideBar_hovered__eF0xN" href="/blog/var-let-const-hoisting/">var, let, const 특징 및 호이스팅</a><a class="undefined " href="/blog/StoryBook%EC%9C%BC%EB%A1%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8/">StoryBook으로 컴포넌트 테스트</a><a class="undefined " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/">Controlled 컴포넌트와 UnControlled 컴포넌트 차이점</a><a class="undefined " href="/blog/React%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%A1%9C%EC%A7%81-%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/">React에서 컴포넌트와 로직 분리하는 방법</a></div></aside><div class="postLayout_postBox__4BFa4"><header class="title_container__fhpAF"><h1>var, let, const 특징 및 호이스팅</h1><span>2023년 4월 25일</span></header><article class="section_container__KqTMH"><article class="content_container__Kx6HO"><h2 id="var-키워드-특징으로-인한-문제점-3가지">var 키워드 특징으로 인한 문제점 3가지</h2>
<ol>
<li>전역 변수 : <code>var</code> 키워드는 전역변수로 선언 할 수 있다. 변수는 유효 범위에 따라 지역 변수과 전역 변수로 구분이 되는데, <code>var</code> 키워드를 사용해서 전역 변수와 변수명이 겹쳐 값을 덮어씌우는 상황이 발생해 잘못 된 값을 참조하여 문제점이 발생할 수 있습니다.</li>
</ol>
<ul>
<li>지역 변수 (local variable) : 함수 내에서 선연된 변수를 가르키고, 변수가 선언된 함수 내에서만 유효하고, 함수가 종료되면 메모리가 사라집니다.</li>
<li>전역 변수 (global variable) : 함수 외에서 선언된 변수를 가르키고, 전역 페이지 어느 곳에서 접근할 수 있고, 웹페이지가 닫혀야만 메모리가 사라집니다.</li>
</ul>
<ol start="2">
<li>
<p>중복 선언 가능 : 중복 선언으로 인한 문제점이 발생합니다. <code>let</code> 과 <code>const</code> 의 경우 같은 스코프에서 동일한 변수명으로 선언을 하게 된 경우 오류가 발생하는데, <code>var</code> 키워드는 동일한 변수명으로 선언해도 오류가 발생하지 않아 값이 달라져 에러가 발생하고, 유지 보수 등에 문제가 발생합니다.</p>
</li>
<li>
<p>변수 호이스팅 : <code>var</code> 키워드의 경우 선언된 후에 <code>undefined</code>로 초기화 되기 떄문에 참조를 해도 에러가 발생하지 않아, 예기치 못한 에러가 발생할 수 있어 개발, 유지 보수 등 문제가 발생할 수 있습니다.</p>
</li>
</ol>
<h2 id="let-키워드-특징-및-var-키워드와-차이점-4가지">let 키워드 특징 및 var 키워드와 차이점 4가지</h2>
<ol>
<li>
<p>중복 선언 불가능 : <code>let</code> 키워드는 재할당은 가능 하지만 동일한 스코프 안에서 중복 선언을 하게 되면 문법 에러가 발생해 재할당이 불가능 합니다. 이는 var 키워드를 사용 했을 때 문제점을 막아주는 역할을 합니다.</p>
</li>
<li>
<p>블록 단위 스코프 : <code>let</code> 키워드로 선언된 변수는 블록 단위 스코프를 따릅니다. 함수 뿐만 아니라 모든 코드의 블록 내에서 선언된 변수는 해당 유효 범위를 벗어나면 읽거나 사용할 수 없습니다.</p>
</li>
<li>
<p>TDZ :<code>let</code> 키워드는 호이스팅시 초기화가 되지 않기 때문에 초기화를 하지 않고 읽거나 사용할 경우 참조 에러가 발생하여 var와 같은 변수 호이스팅 문제가 발생하지 않습니다. 이러한 선언 부터 초기화가 되는 시점, 변수를 참조 할 수 없는 영역을 <code>TDZ</code>(Temporal Dead Zone, 일시적 사각지대)라고 합니다.</p>
</li>
<li>
<p>지역 변수 : <code>let</code> 키워드는 지역 변수로 선언하기 때문에 var 키워드의 문제점인 전역 변수로 중복 선언되는 문제점이 없습니다.</p>
</li>
</ol>
<h2 id="const-키워드-특징-3가지">const 키워드 특징 3가지</h2>
<ol>
<li>선언과 초기화 : <code>const</code> 키워드는 <code>let</code> 키워드와 다르게 선언과 초기화를 동시에 하지 않으면 문법 에러가 발생하게 됩니다.</li>
<li>재할당 불가능 : <code>var</code> 키워드, <code>let</code> 키워드는 재할당이 가능 하지만 const 키워드는 재할당이 불가능 합니다.</li>
<li>상수 : <code>const</code> 키워드로 선언한 변수에 원시값을 할당한 경우 변수 값을 변경할 수 없습니다. 원시 값은 변경이 불가능한 값이므로 재할당이 없이 값을 변경할 수 없어서 <code>const</code>를 사용하면 상수값으로 사용할 수 있습니다.</li>
</ol>
<ul>
<li>원시값은 재할당이 불가능 하지만 객체같은 참조 값은 얼마든지 변경이 가능합니다. 그래서 함수나, 배열 메소드 등을 사용하여 새로운 변수를 만들 때 객체 값들을 변경해서 새로운 값이나 배열 등을 만들어도 오류가 생기지 않습니다.</li>
</ul>
<h2 id="호이스팅이란">호이스팅이란?</h2>
<p>실행 컨텍스트의 생성 단계에서 변수 및 함수 선언을 해당 범위 최상단에 올리는 동작입니다.
이러한 동작을 하게 되면 실제로 정의되기 전에 변수와 함수를 참조할 수 있지만 할당이 아닌 선언 자체만 호이스팅됩니다.</p></article></article><div class="postLayout_comment__mmog_"><section></section></div></div><aside class="TOC_tocContainer__xG3B8"><div class="TOC_toc__bb4qM"><div>Table of Content</div><a class="TOC_mainHead__UCw15 " href="/blog/var-let-const-hoisting/#var-%ED%82%A4%EC%9B%8C%EB%93%9C-%ED%8A%B9%EC%A7%95%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90-3%EA%B0%80%EC%A7%80">var 키워드 특징으로 인한 문제점 3가지</a><a class="TOC_mainHead__UCw15 " href="/blog/var-let-const-hoisting/#let-%ED%82%A4%EC%9B%8C%EB%93%9C-%ED%8A%B9%EC%A7%95-%EB%B0%8F-var-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%99%80-%EC%B0%A8%EC%9D%B4%EC%A0%90-4%EA%B0%80%EC%A7%80">let 키워드 특징 및 var 키워드와 차이점 4가지</a><a class="TOC_mainHead__UCw15 " href="/blog/var-let-const-hoisting/#const-%ED%82%A4%EC%9B%8C%EB%93%9C-%ED%8A%B9%EC%A7%95-3%EA%B0%80%EC%A7%80">const 키워드 특징 3가지</a><a class="TOC_mainHead__UCw15 " href="/blog/var-let-const-hoisting/#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80">호이스팅이란?</a></div></aside></div></div></main><footer class="footer_footerContainer__M6t1B"><div class="footer_copy__6DxmK">Copyright © 2024 WaterHumanB</div><div class="footer_devBox__UPiww"><a class="footer_dev__wo6Qp" target="_blank" href="https://github.com/waterhumanB/waterhumanb.dev"><div>WaterHumanB.dev</div></a></div></footer></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"slug":"var-let-const-hoisting","allBlogData":[{"slug":"코어-자바스크립트-질문-리스트","title":"코어 자바스크립트 질문 리스트","date":"2024년 11월 25일","description":"코어 자바스크립트를 읽고 프론트엔드 개발자로 생각 할 수 있는 기술면접 질문 리스트","thumbnail":"","category":"JavaScript"},{"slug":"자바스크립트-TDD-With-Next-Step","title":"자바스크립트 TDD와 jest 기본 사용법","date":"2023년 7월 23일","description":"자바스크립트 TDD와 Jest 기본 사용 법 및 Next Step 시작","thumbnail":"","category":"JavaScript"},{"slug":"next.js-블로그-회고","title":"Next.js 블로그 첫 번째 회고","date":"2023년 6월 25일","description":"Next.js 블로그 개발 기능 설명 및 첫 번째 회고","thumbnail":"/profile.jpg","category":"Next.js"},{"slug":"점진적과부하-프로젝트-회고","title":"점진적과부하 프로젝트 회고","date":"2023년 5월 22일","description":"점진적과부하 개인 프로젝트 설명 및 회고","thumbnail":"","category":"React"},{"slug":"라이브러리-없이-캘린더-만들기","title":"라이브러리 없이 캘린더 만들기","date":"2023년 5월 15일","description":"라이브러리 없이 Date 메소드 활용 캘린더 만들기","thumbnail":"/assets/images/blog/calendar.png","category":"React"},{"slug":"라이브러리-없이-그래프,-차트-만들기","title":"라이브러리 없이 그래프, 차트 만들기","date":"2023년 5월 08일","description":"라이브러리 없이 SVG 태그를 활용 막대 그래프와 도넛 차트를 만드는 방법","thumbnail":"/assets/images/blog/SVG tag graphs and charts.png","category":"HTML"},{"slug":"Redux와-데이터정규화","title":"Redux와 데이터정규화","date":"2023년 5월 03일","description":"점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화","thumbnail":"","category":"DataBase"},{"slug":"var-let-const-hoisting","title":"var, let, const 특징 및 호이스팅","date":"2023년 4월 25일","description":"var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리","thumbnail":"","category":"JavaScript"},{"slug":"StoryBook으로-컴포넌트-테스트","title":"StoryBook으로 컴포넌트 테스트","date":"2023년 4월 18일","description":"StoryBook을 사용하여 React에서 컴포넌트 테스트를 해보자!","thumbnail":"","category":"Storybook"},{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"},{"slug":"React에서-컴포넌트와-로직-분리하는-방법","title":"React에서 컴포넌트와 로직 분리하는 방법","date":"2023년 4월 03일","description":"React에서 Hook, Utils, Domain으로 컴포넌트와 로직 분리하는 이유와 방법","thumbnail":"","category":"React"}],"fallback":{"@\"Props\",\"var-let-const-hoisting\",":{"slug":"var-let-const-hoisting","content":"\n## var 키워드 특징으로 인한 문제점 3가지\n\n1. 전역 변수 : `var` 키워드는 전역변수로 선언 할 수 있다. 변수는 유효 범위에 따라 지역 변수과 전역 변수로 구분이 되는데, `var` 키워드를 사용해서 전역 변수와 변수명이 겹쳐 값을 덮어씌우는 상황이 발생해 잘못 된 값을 참조하여 문제점이 발생할 수 있습니다.\n\n- 지역 변수 (local variable) : 함수 내에서 선연된 변수를 가르키고, 변수가 선언된 함수 내에서만 유효하고, 함수가 종료되면 메모리가 사라집니다.\n- 전역 변수 (global variable) : 함수 외에서 선언된 변수를 가르키고, 전역 페이지 어느 곳에서 접근할 수 있고, 웹페이지가 닫혀야만 메모리가 사라집니다.\n\n2. 중복 선언 가능 : 중복 선언으로 인한 문제점이 발생합니다. `let` 과 `const` 의 경우 같은 스코프에서 동일한 변수명으로 선언을 하게 된 경우 오류가 발생하는데, `var` 키워드는 동일한 변수명으로 선언해도 오류가 발생하지 않아 값이 달라져 에러가 발생하고, 유지 보수 등에 문제가 발생합니다.\n\n3. 변수 호이스팅 : `var` 키워드의 경우 선언된 후에 `undefined`로 초기화 되기 떄문에 참조를 해도 에러가 발생하지 않아, 예기치 못한 에러가 발생할 수 있어 개발, 유지 보수 등 문제가 발생할 수 있습니다.\n\n## let 키워드 특징 및 var 키워드와 차이점 4가지\n\n1. 중복 선언 불가능 : `let` 키워드는 재할당은 가능 하지만 동일한 스코프 안에서 중복 선언을 하게 되면 문법 에러가 발생해 재할당이 불가능 합니다. 이는 var 키워드를 사용 했을 때 문제점을 막아주는 역할을 합니다.\n\n2. 블록 단위 스코프 : `let` 키워드로 선언된 변수는 블록 단위 스코프를 따릅니다. 함수 뿐만 아니라 모든 코드의 블록 내에서 선언된 변수는 해당 유효 범위를 벗어나면 읽거나 사용할 수 없습니다.\n\n3. TDZ :`let` 키워드는 호이스팅시 초기화가 되지 않기 때문에 초기화를 하지 않고 읽거나 사용할 경우 참조 에러가 발생하여 var와 같은 변수 호이스팅 문제가 발생하지 않습니다. 이러한 선언 부터 초기화가 되는 시점, 변수를 참조 할 수 없는 영역을 `TDZ`(Temporal Dead Zone, 일시적 사각지대)라고 합니다.\n\n4. 지역 변수 : `let` 키워드는 지역 변수로 선언하기 때문에 var 키워드의 문제점인 전역 변수로 중복 선언되는 문제점이 없습니다.\n\n## const 키워드 특징 3가지\n\n1. 선언과 초기화 : `const` 키워드는 `let` 키워드와 다르게 선언과 초기화를 동시에 하지 않으면 문법 에러가 발생하게 됩니다.\n2. 재할당 불가능 : `var` 키워드, `let` 키워드는 재할당이 가능 하지만 const 키워드는 재할당이 불가능 합니다.\n3. 상수 : `const` 키워드로 선언한 변수에 원시값을 할당한 경우 변수 값을 변경할 수 없습니다. 원시 값은 변경이 불가능한 값이므로 재할당이 없이 값을 변경할 수 없어서 `const`를 사용하면 상수값으로 사용할 수 있습니다.\n\n- 원시값은 재할당이 불가능 하지만 객체같은 참조 값은 얼마든지 변경이 가능합니다. 그래서 함수나, 배열 메소드 등을 사용하여 새로운 변수를 만들 때 객체 값들을 변경해서 새로운 값이나 배열 등을 만들어도 오류가 생기지 않습니다.\n\n## 호이스팅이란?\n\n실행 컨텍스트의 생성 단계에서 변수 및 함수 선언을 해당 범위 최상단에 올리는 동작입니다.\n이러한 동작을 하게 되면 실제로 정의되기 전에 변수와 함수를 참조할 수 있지만 할당이 아닌 선언 자체만 호이스팅됩니다.\n","title":"var, let, const 특징 및 호이스팅","date":"2023년 4월 25일","description":"var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리","thumbnail":"","category":"JavaScript"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"var-let-const-hoisting"},"buildId":"xSQOQ32O3HBNjY_uIzKPY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>