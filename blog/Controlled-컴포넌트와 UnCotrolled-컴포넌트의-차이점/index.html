<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@site"/><meta name="twitter:creator" content="@handle"/><link rel="canonical" href="https://waterhumanb.github.io"/><title>Controlled 컴포넌트와 UnControlled 컴포넌트 차이점</title><meta name="robots" content="index,follow"/><meta name="description" content="React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자"/><meta property="og:title" content="Controlled 컴포넌트와 UnControlled 컴포넌트 차이점"/><meta property="og:description" content="React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자"/><meta property="og:url" content="https://waterhumanb.github.io/blog/Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점"/><meta property="og:type" content="website"/><meta property="og:image" content=""/><meta property="og:image:alt" content="이미지"/><meta property="og:image:width" content="285"/><meta property="og:image:height" content="167"/><meta property="og:locale" content="ko_KR"/><meta property="og:site_name" content="waterhumanb.dev"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="UBbrn6uYlvgqUuPSNz6397TblWqGKuSHzwf_e2jijxk"/><meta name="naver-site-verification" content="5b4676776e4bf7929cd196996b0da94331749653"/><link rel="preload" href="/_next/static/css/d8bed1e24432d094.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d8bed1e24432d094.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/ae9d48751daeccdb.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/ae9d48751daeccdb.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-26292afa9ac61214.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-e14092e0d084b50d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-de761518420b1770.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-144889350ae033c1.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/664-4376551f6398547f.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/675-a22d097d5bbbe350.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/972-cbebcee7e82a5949.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-ef6dc5c9b42e3c93.js" defer="" crossorigin=""></script><script src="/_next/static/HstNFDYMYBk7yzRF4J0tt/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/HstNFDYMYBk7yzRF4J0tt/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><header class="header_header___ROMs"><div class="nav_nav__8z_BE"><div><a href="/"><div class="">Home</div></a></div><nav class="nav_navLinks__n71QG"><a href="/blog/"><div class="nav_active__ZBV7z">Blog</div></a><a href="/note/"><div class="">Note</div></a></nav></div></header><main class="layout_container__12fKi"><div><div class="postLayout_postContainer__sy9uX"><aside class="sideBar_sideBarContainer___AvzN"><div class="sideBar_sideBar__xUXBW"><div>Blog<!-- --> Menu</div><a class="undefined " href="/blog/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8/">코어 자바스크립트 질문 리스트</a><a class="undefined " href="/blog/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-TDD-With-Next-Step/">자바스크립트 TDD와 jest 기본 사용법</a><a class="undefined " href="/blog/next.js-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%9A%8C%EA%B3%A0">Next.js 블로그 첫 번째 회고</a><a class="undefined " href="/blog/%EC%A0%90%EC%A7%84%EC%A0%81%EA%B3%BC%EB%B6%80%ED%95%98-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0/">점진적과부하 프로젝트 회고</a><a class="undefined " href="/blog/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%97%86%EC%9D%B4-%EC%BA%98%EB%A6%B0%EB%8D%94-%EB%A7%8C%EB%93%A4%EA%B8%B0/">라이브러리 없이 캘린더 만들기</a><a class="undefined " href="/blog/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%97%86%EC%9D%B4-%EA%B7%B8%EB%9E%98%ED%94%84,-%EC%B0%A8%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/">라이브러리 없이 그래프, 차트 만들기</a><a class="undefined " href="/blog/Redux%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%95%EA%B7%9C%ED%99%94/">Redux와 데이터정규화</a><a class="undefined " href="/blog/var-let-const-hoisting/">var, let, const 특징 및 호이스팅</a><a class="undefined " href="/blog/StoryBook%EC%9C%BC%EB%A1%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8/">StoryBook으로 컴포넌트 테스트</a><a class="undefined sideBar_hovered__eF0xN" href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/">Controlled 컴포넌트와 UnControlled 컴포넌트 차이점</a><a class="undefined " href="/blog/React%EC%97%90%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%A1%9C%EC%A7%81-%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/">React에서 컴포넌트와 로직 분리하는 방법</a></div></aside><div class="postLayout_postBox__4BFa4"><header class="title_container__fhpAF"><h1>Controlled 컴포넌트와 UnControlled 컴포넌트 차이점</h1><span>2023년 4월 12일</span></header><article class="section_container__KqTMH"><article class="content_container__Kx6HO"><h2 id="controlled-component">Controlled Component</h2>
<blockquote>
<p>HTML에서 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code>와 같은 폼 엘리먼트는 일반적으로 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트합니다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트됩니다.
우리는 React state를 “신뢰 가능한 단일 출처 (single source of truth)“로 만들어 두 요소를 결합할 수 있습니다. 그러면 폼을 렌더링하는 React 컴포넌트는 폼에 발생하는 사용자 입력값을 제어합니다. 이러한 방식으로 React에 의해 값이 제어되는 입력 폼 엘리먼트를 “제어 컴포넌트 (controlled component)“라고 합니다.</p>
<p>출처 : <a href="https://ko.legacy.reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener noreferrer">https://ko.legacy.reactjs.org/docs/forms.html#controlled-components</a></p>
</blockquote>
<p>공식문서에서 위와 같은 설명을 해주고 있습니다. 쉽게 말해 입력폼에 <code>state</code>를 통해 관리를 하고 제어하는 것이 <code>Controlled Component</code>입니다.</p>
<p>아마도 흔히 <code>React</code>로 로그인, 회원가입, 게시글, 댓글 등 입력할 수 있는 컴포넌트를 구현할 때, <code>&lt;input&gt;</code>를 활용해서 <code>useState</code>를 통해 값을 입력받고, 유효성 검사, 서버에 전달 등 기능을 구현합니다.</p>
<h2 id="uncontrolled-component">UnControlled Component</h2>
<p>비제어 컴포넌트란 무엇인가?</p>
<p>자료를 찾아보니 전통적인 방식이라고 많이 표현하는 것을 보았는데, <code>React</code>같은 라이브러리나 <code>Next.js</code>같은 프레임워크 등이 등장하기 전에는 <code>JavaScript</code>로 <code>DOM</code>을 직접 조작하여 우리가 원하는 기능을 만들었습니다.</p>
<p><code>React</code>에서는 <code>ref</code>를 이용해서 직접 <code>DOM</code>을 조작할 수 있습니다.</p>
<p>쉽게 말해 <code>React</code>에서 <code>ref</code>로 컴포넌트를 조작하면 비제어 컴포넌트가 되는 것이죠.</p>
<h2 id="제어-컴포넌트와-비제어-컴포넌트의-차이점">제어 컴포넌트와 비제어 컴포넌트의 차이점</h2>
<p>그렇다면 제어 컴포넌트와 비제어 컴포넌트의 차이점은 무엇일까?</p>
<p>제어가 가능하고 제어가 불가능 하다는 의미가 무엇일까?</p>
<p>위에서 말했던 제어 컴포넌트는 <code>state</code> 상태값을 가지고 컴포넌트를 제어합니다.</p>
<p><code>React</code>에서 렌더링이 되는 조건을 보면, 부모 요소가 변경될때, 상태값이 변경될 때 입니다.</p>
<p><code>State</code>가 변경되면서 해당 컴포넌트의 데이터와 <code>State</code>의 데이터가 동기화 되면서, 웹에서도 사용자가 어떤 행동을 하는지 알 수 있습니다.</p>
<p>반대로 <code>ref</code>를 통해 직접 <code>DOM</code>을 조작한다면, 웹은 사용자가 어떤 동작을 하는지 알 수 없습니다. 만약 <code>ID</code>를 입력 받는 <code>&lt;Input&gt;</code> 컴포넌트를 사용해서 <code>&lt;Button</code>을 누르면 데이터가 전송된다고 했을 때, 버튼을 누르기 전까지 웹에서는 사용자가 어떤 값을 입력했는지 알 수 없는 것이죠.</p>
<p>그렇기 때문에 비제어 컴포넌트라고 합니다.</p>
<h2 id="제어-컴포넌트와-비제어-컴포넌트의-장단점">제어 컴포넌트와 비제어 컴포넌트의 장단점</h2>
<h3 id="장점">장점</h3>
<p><strong>제어 컴포넌트</strong>
제어 컴포넌트는 주로 유효성 검사를 할 때 사용합니다.
우리가 이메일, ID, 비밀번호 등 사용자가 입력한 값들을 즉각적으로 판단하고 사용자에게 보여주려면, 사용자가 입력한 값과 <code>State</code>값을 동기화 시켜 바로바로 검사를 해주는 것이 좋겠죠.</p>
<p><strong>비제어 컴포넌트</strong>
비제어 컴포넌트는 제어 컴포넌트 처럼 입력한 값을 즉각적으로 판단하지 않고, 필요할 때 입력값을 추출할 경우에 사용합니다. ID나 비밀번호 등 중요한 정보들은 즉각적으로 유효성검사를 해서 사용자에게 바로바로 피드백을 줘야하지만, 만약 자기소개같은 정보는 굳이 데이터와 상태를 동기화 시켜 입력받을 필요는 없기 때문입니다.</p>
<h3 id="단점">단점</h3>
<p><strong>제어 컴포넌트</strong>
제어 컴포넌트의 단점은 단어 하나하나 입력할 때 마다 값이 갱신되어 불필요하게 렌더링이 되어 성능 측면에 좋지 않고, 만약 바로바로 <code>API</code>호출이 된다면, 자원 낭비가 되겠죠.</p>
<pre><pre node="[object Object]" style="background:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%);font-family:&quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0.5em 0;overflow:auto;border-radius:0.3em"><code class="language-ts" style="white-space:pre;background:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%);font-family:&quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;direction:ltr;text-align:left;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:hsl(301, 63%, 40%)">const</span><span> </span><span class="token function-variable maybe-class-name" style="color:hsl(221, 87%, 60%)">Test</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">=</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">(</span><span class="token" style="color:hsl(230, 8%, 24%)">)</span><span> </span><span class="token arrow" style="color:hsl(221, 87%, 60%)">=&gt;</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">{</span><span>
</span><span>  </span><span class="token" style="color:hsl(301, 63%, 40%)">const</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">[</span><span>id</span><span class="token" style="color:hsl(230, 8%, 24%)">,</span><span> setId</span><span class="token" style="color:hsl(230, 8%, 24%)">]</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">=</span><span> </span><span class="token" style="color:hsl(221, 87%, 60%)">useState</span><span class="token" style="color:hsl(230, 8%, 24%)">(</span><span class="token" style="color:hsl(119, 34%, 47%)">&quot;&quot;</span><span class="token" style="color:hsl(230, 8%, 24%)">)</span><span>
</span><span>  </span><span class="token console" style="color:hsl(35, 99%, 36%)">console</span><span class="token" style="color:hsl(230, 8%, 24%)">.</span><span class="token method property-access" style="color:hsl(221, 87%, 60%)">log</span><span class="token" style="color:hsl(230, 8%, 24%)">(</span><span>id</span><span class="token" style="color:hsl(230, 8%, 24%)">)</span><span>
</span><span>  </span><span class="token control-flow" style="color:hsl(301, 63%, 40%)">return</span><span> </span><span class="token" style="color:hsl(230, 8%, 24%)">(</span><span>
</span><span>    </span><span class="token" style="color:hsl(221, 87%, 60%)">&lt;</span><span>div</span><span class="token" style="color:hsl(221, 87%, 60%)">&gt;</span><span>
</span><span>      </span><span class="token" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token" style="color:hsl(221, 87%, 60%)">/</span><span>input onChange</span><span class="token" style="color:hsl(221, 87%, 60%)">=</span><span class="token" style="color:hsl(230, 8%, 24%)">{</span><span>setId</span><span class="token" style="color:hsl(230, 8%, 24%)">}</span><span class="token" style="color:hsl(221, 87%, 60%)">&gt;</span><span>
</span><span>    </span><span class="token" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token" style="color:hsl(221, 87%, 60%)">/</span><span>div</span><span class="token" style="color:hsl(221, 87%, 60%)">&gt;</span><span>
</span><span>  </span><span class="token" style="color:hsl(230, 8%, 24%)">)</span><span>
</span><span></span><span class="token" style="color:hsl(230, 8%, 24%)">}</span></code></pre></pre>
<p>이렇게 <code>&lt;Input&gt;</code>으로 <code>waterHumanB</code>를 입력한다고 할 때 <code>console.log</code>를 보면</p>
<pre><pre node="[object Object]" style="background:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%);font-family:&quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0.5em 0;overflow:auto;border-radius:0.3em"><code class="language-ts" style="white-space:pre;background:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%);font-family:&quot;Fira Code&quot;, &quot;Fira Mono&quot;, Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;direction:ltr;text-align:left;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>w
</span>wa
<!-- -->wat
<!-- -->wate
<!-- -->water
<!-- -->waterH
<!-- -->waterHu
<!-- -->waterHum
<!-- -->waterHuma
<!-- -->waterHuman
<!-- -->waterHumanB</code></pre></pre>
<p>이런 식으로 모든 값을 받아오게 되면서 계속 계속 렌더링이 될겁니다.</p>
<p>이를 방지하기 위해서는 <code>Throttle</code>과 <code>Debounce</code>를 사용하면 됩니다.</p>
<blockquote>
<p>쓰로틀<code>Throttle</code> : 연속된 이벤트를 호출하지 않고 일정 시간 간격으로 이벤트가 최대한 한번만 호출하게 합니다.
ex) 무한 스크롤 UI구현 같은 이벤트에 사용합니다.
디바운싱<code>Debounce</code> : 연속된 이벤트를 호출하지 않고 일정 시간이 경과한 이후 한번만 호출 합니다.
ex) 입력 필드 자동완성, 버튼 중복 클릭 방지 처리에 유용합니다.</p>
</blockquote>
<p><strong>비제어 컴포넌트</strong></p>
<p>비제어 컴포넌트의 단점은 제어 컴포넌트의 장점의 반대라고 생각하면 됩니다.
입력된 데이터를 상태값과 동기화 되지 않기 때문에, 유효성 검사 같은 기능은 구현할 수 없겠죠.</p>
<p>입력 받는 값을 알 수 없으니, 테스트나 디버깅에도 어렵습니다.</p>
<p>제어 컴포넌트와 비제어 컴포넌트를 적절히 사용해서, 단점들을 보안해서 사용하면 될거 같아요.</p>
<p>마지막으로 표를 보면 간단하게 정리를 했습니다.</p>













































<table><thead><tr><th>특징</th><th>비제어</th><th>제어</th></tr></thead><tbody><tr><td>일회성 값 검색(예: 제출 시)</td><td>✅</td><td>✅</td></tr><tr><td>제출 시 유효성 검사</td><td>✅</td><td>✅</td></tr><tr><td>즉각적인 필드 유효성 검사</td><td>❌</td><td>✅</td></tr><tr><td>조건부 제출 버튼 비활성화</td><td>❌</td><td>✅</td></tr><tr><td>입력 형식 적용</td><td>❌</td><td>✅</td></tr><tr><td>하나의 데이터에 대한 여러 입력</td><td>❌</td><td>✅</td></tr><tr><td>동적 입력</td><td>❌</td><td>✅</td></tr></tbody></table>
<p>그리고 무조건 제어, 비제어 나누지 않고, 언제든지 비제어 컴포넌트를 제어 컴포넌트로 마이그레이션 가능합니다.</p>
<p>뭐든지 상황에 맞게 기능을 구현하는게 정답인거 같네요.</p>
<h2 id="회고">회고</h2>
<p>처음 제어, 비제어 컴포넌트라는 용어를 들었을 때 아무생각도 들지 않았고 단순히 <code>state</code>사용과 <code>ref</code>사용 이정도로 끝냈었다.</p>
<p>생각해 보면, 사용자의 정보를 얻고 유효성 검사를 했을 때 무조건 <code>state</code>를 사용해서 관리를 했고, 무한 스크롤 같은 UI를 구현할 때는 <code>ref</code>로 구현을 했었다.</p>
<p>무의식 적으로 이렇게 하는게 편하고, 그렇게 했으니까? 이런 생각들로 구현을 했었는데,</p>
<p>이제는 좀 더 내가 왜 이렇게 구현했는지, 의미를 알 수 있고, <code>&lt;Input&gt;</code>으로 입력된 데이터를 처리할 때, 어떤 방식이 좀 더 효율적인지 알게 되었다.</p>
<p>아직도 부족하지만, 나의 코드가 어떤 의미이고, 왜 이렇게 했는지 조금은 설명이 더 할 수 있을 것 같다.</p>
<h4 id="참고-자료">참고 자료</h4>
<ul>
<li><a href="https://ko.legacy.reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener noreferrer">https://ko.legacy.reactjs.org/docs/forms.html#controlled-components</a></li>
<li><a href="https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/" target="_blank" rel="noopener noreferrer">https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/</a></li>
</ul></article></article><div class="postLayout_comment__mmog_"><section></section></div></div><aside class="TOC_tocContainer__xG3B8"><div class="TOC_toc__bb4qM"><div>Table of Content</div><a class="TOC_mainHead__UCw15 " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#controlled-component">Controlled Component</a><a class="TOC_mainHead__UCw15 " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#uncontrolled-component">UnControlled Component</a><a class="TOC_mainHead__UCw15 " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%B9%84%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">제어 컴포넌트와 비제어 컴포넌트의 차이점</a><a class="TOC_mainHead__UCw15 " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%B9%84%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90">제어 컴포넌트와 비제어 컴포넌트의 장단점</a><a class="TOC_subHead__zXtIP " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#%EC%9E%A5%EC%A0%90">장점</a><a class="TOC_subHead__zXtIP " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#%EB%8B%A8%EC%A0%90">단점</a><a class="TOC_mainHead__UCw15 " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#%ED%9A%8C%EA%B3%A0">회고</a><a class="TOC_subHead__zXtIP " href="/blog/Controlled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80%20UnCotrolled-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C">참고 자료</a></div></aside></div></div></main><footer class="footer_footerContainer__M6t1B"><div class="footer_copy__6DxmK">Copyright © 2024 WaterHumanB</div><div class="footer_devBox__UPiww"><a class="footer_dev__wo6Qp" target="_blank" href="https://github.com/waterhumanB/waterhumanb.dev"><div>WaterHumanB.dev</div></a></div></footer></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","allBlogData":[{"slug":"코어-자바스크립트-질문-리스트","title":"코어 자바스크립트 질문 리스트","date":"2024년 11월 25일","description":"코어 자바스크립트를 읽고 프론트엔드 개발자로 생각 할 수 있는 기술면접 질문 리스트","thumbnail":"","category":"JavaScript"},{"slug":"자바스크립트-TDD-With-Next-Step","title":"자바스크립트 TDD와 jest 기본 사용법","date":"2023년 7월 23일","description":"자바스크립트 TDD와 Jest 기본 사용 법 및 Next Step 시작","thumbnail":"","category":"JavaScript"},{"slug":"next.js-블로그-회고","title":"Next.js 블로그 첫 번째 회고","date":"2023년 6월 25일","description":"Next.js 블로그 개발 기능 설명 및 첫 번째 회고","thumbnail":"/profile.jpg","category":"Next.js"},{"slug":"점진적과부하-프로젝트-회고","title":"점진적과부하 프로젝트 회고","date":"2023년 5월 22일","description":"점진적과부하 개인 프로젝트 설명 및 회고","thumbnail":"","category":"React"},{"slug":"라이브러리-없이-캘린더-만들기","title":"라이브러리 없이 캘린더 만들기","date":"2023년 5월 15일","description":"라이브러리 없이 Date 메소드 활용 캘린더 만들기","thumbnail":"/assets/images/blog/calendar.png","category":"React"},{"slug":"라이브러리-없이-그래프,-차트-만들기","title":"라이브러리 없이 그래프, 차트 만들기","date":"2023년 5월 08일","description":"라이브러리 없이 SVG 태그를 활용 막대 그래프와 도넛 차트를 만드는 방법","thumbnail":"/assets/images/blog/SVG tag graphs and charts.png","category":"HTML"},{"slug":"Redux와-데이터정규화","title":"Redux와 데이터정규화","date":"2023년 5월 03일","description":"점진적 과부하 프로젝트에서 사용했던 리덕스와 데이터 정규화","thumbnail":"","category":"DataBase"},{"slug":"var-let-const-hoisting","title":"var, let, const 특징 및 호이스팅","date":"2023년 4월 25일","description":"var, let, const 키워드들의 특징과 차이점과 호이스팅에 대한 정리","thumbnail":"","category":"JavaScript"},{"slug":"StoryBook으로-컴포넌트-테스트","title":"StoryBook으로 컴포넌트 테스트","date":"2023년 4월 18일","description":"StoryBook을 사용하여 React에서 컴포넌트 테스트를 해보자!","thumbnail":"","category":"Storybook"},{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"},{"slug":"React에서-컴포넌트와-로직-분리하는-방법","title":"React에서 컴포넌트와 로직 분리하는 방법","date":"2023년 4월 03일","description":"React에서 Hook, Utils, Domain으로 컴포넌트와 로직 분리하는 이유와 방법","thumbnail":"","category":"React"}],"fallback":{"@\"Props\",\"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점\",":{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점","content":"\n## Controlled Component\n\n\u003e HTML에서 `\u003cinput\u003e`, `\u003ctextarea\u003e`, `\u003cselect\u003e`와 같은 폼 엘리먼트는 일반적으로 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트합니다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트됩니다.\n\u003e 우리는 React state를 “신뢰 가능한 단일 출처 (single source of truth)“로 만들어 두 요소를 결합할 수 있습니다. 그러면 폼을 렌더링하는 React 컴포넌트는 폼에 발생하는 사용자 입력값을 제어합니다. 이러한 방식으로 React에 의해 값이 제어되는 입력 폼 엘리먼트를 “제어 컴포넌트 (controlled component)“라고 합니다.\n\u003e\n\u003e 출처 : https://ko.legacy.reactjs.org/docs/forms.html#controlled-components\n\n공식문서에서 위와 같은 설명을 해주고 있습니다. 쉽게 말해 입력폼에 `state`를 통해 관리를 하고 제어하는 것이 `Controlled Component`입니다.\n\n아마도 흔히 `React`로 로그인, 회원가입, 게시글, 댓글 등 입력할 수 있는 컴포넌트를 구현할 때, `\u003cinput\u003e`를 활용해서 `useState`를 통해 값을 입력받고, 유효성 검사, 서버에 전달 등 기능을 구현합니다.\n\n## UnControlled Component\n\n비제어 컴포넌트란 무엇인가?\n\n자료를 찾아보니 전통적인 방식이라고 많이 표현하는 것을 보았는데, `React`같은 라이브러리나 `Next.js`같은 프레임워크 등이 등장하기 전에는 `JavaScript`로 `DOM`을 직접 조작하여 우리가 원하는 기능을 만들었습니다.\n\n`React`에서는 `ref`를 이용해서 직접 `DOM`을 조작할 수 있습니다.\n\n쉽게 말해 `React`에서 `ref`로 컴포넌트를 조작하면 비제어 컴포넌트가 되는 것이죠.\n\n## 제어 컴포넌트와 비제어 컴포넌트의 차이점\n\n그렇다면 제어 컴포넌트와 비제어 컴포넌트의 차이점은 무엇일까?\n\n제어가 가능하고 제어가 불가능 하다는 의미가 무엇일까?\n\n위에서 말했던 제어 컴포넌트는 `state` 상태값을 가지고 컴포넌트를 제어합니다.\n\n`React`에서 렌더링이 되는 조건을 보면, 부모 요소가 변경될때, 상태값이 변경될 때 입니다.\n\n`State`가 변경되면서 해당 컴포넌트의 데이터와 `State`의 데이터가 동기화 되면서, 웹에서도 사용자가 어떤 행동을 하는지 알 수 있습니다.\n\n반대로 `ref`를 통해 직접 `DOM`을 조작한다면, 웹은 사용자가 어떤 동작을 하는지 알 수 없습니다. 만약 `ID`를 입력 받는 `\u003cInput\u003e` 컴포넌트를 사용해서 `\u003cButton`을 누르면 데이터가 전송된다고 했을 때, 버튼을 누르기 전까지 웹에서는 사용자가 어떤 값을 입력했는지 알 수 없는 것이죠.\n\n그렇기 때문에 비제어 컴포넌트라고 합니다.\n\n## 제어 컴포넌트와 비제어 컴포넌트의 장단점\n\n### 장점\n\n**제어 컴포넌트**\n제어 컴포넌트는 주로 유효성 검사를 할 때 사용합니다.\n우리가 이메일, ID, 비밀번호 등 사용자가 입력한 값들을 즉각적으로 판단하고 사용자에게 보여주려면, 사용자가 입력한 값과 `State`값을 동기화 시켜 바로바로 검사를 해주는 것이 좋겠죠.\n\n**비제어 컴포넌트**\n비제어 컴포넌트는 제어 컴포넌트 처럼 입력한 값을 즉각적으로 판단하지 않고, 필요할 때 입력값을 추출할 경우에 사용합니다. ID나 비밀번호 등 중요한 정보들은 즉각적으로 유효성검사를 해서 사용자에게 바로바로 피드백을 줘야하지만, 만약 자기소개같은 정보는 굳이 데이터와 상태를 동기화 시켜 입력받을 필요는 없기 때문입니다.\n\n### 단점\n\n**제어 컴포넌트**\n제어 컴포넌트의 단점은 단어 하나하나 입력할 때 마다 값이 갱신되어 불필요하게 렌더링이 되어 성능 측면에 좋지 않고, 만약 바로바로 `API`호출이 된다면, 자원 낭비가 되겠죠.\n\n```ts\nconst Test = () =\u003e {\n  const [id, setId] = useState(\"\")\n  console.log(id)\n  return (\n    \u003cdiv\u003e\n      \u003c/input onChange={setId}\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n이렇게 `\u003cInput\u003e`으로 `waterHumanB`를 입력한다고 할 때 `console.log`를 보면\n\n```ts\nw\nwa\nwat\nwate\nwater\nwaterH\nwaterHu\nwaterHum\nwaterHuma\nwaterHuman\nwaterHumanB\n```\n\n이런 식으로 모든 값을 받아오게 되면서 계속 계속 렌더링이 될겁니다.\n\n이를 방지하기 위해서는 `Throttle`과 `Debounce`를 사용하면 됩니다.\n\n\u003e 쓰로틀`Throttle` : 연속된 이벤트를 호출하지 않고 일정 시간 간격으로 이벤트가 최대한 한번만 호출하게 합니다.\n\u003e ex) 무한 스크롤 UI구현 같은 이벤트에 사용합니다.\n\u003e 디바운싱`Debounce` : 연속된 이벤트를 호출하지 않고 일정 시간이 경과한 이후 한번만 호출 합니다.\n\u003e ex) 입력 필드 자동완성, 버튼 중복 클릭 방지 처리에 유용합니다.\n\n**비제어 컴포넌트**\n\n비제어 컴포넌트의 단점은 제어 컴포넌트의 장점의 반대라고 생각하면 됩니다.\n입력된 데이터를 상태값과 동기화 되지 않기 때문에, 유효성 검사 같은 기능은 구현할 수 없겠죠.\n\n입력 받는 값을 알 수 없으니, 테스트나 디버깅에도 어렵습니다.\n\n제어 컴포넌트와 비제어 컴포넌트를 적절히 사용해서, 단점들을 보안해서 사용하면 될거 같아요.\n\n마지막으로 표를 보면 간단하게 정리를 했습니다.\n\n| 특징                           | 비제어 | 제어 |\n| ------------------------------ | ------ | ---- |\n| 일회성 값 검색(예: 제출 시)    | ✅     | ✅   |\n| 제출 시 유효성 검사            | ✅     | ✅   |\n| 즉각적인 필드 유효성 검사      | ❌     | ✅   |\n| 조건부 제출 버튼 비활성화      | ❌     | ✅   |\n| 입력 형식 적용                 | ❌     | ✅   |\n| 하나의 데이터에 대한 여러 입력 | ❌     | ✅   |\n| 동적 입력                      | ❌     | ✅   |\n\n그리고 무조건 제어, 비제어 나누지 않고, 언제든지 비제어 컴포넌트를 제어 컴포넌트로 마이그레이션 가능합니다.\n\n뭐든지 상황에 맞게 기능을 구현하는게 정답인거 같네요.\n\n## 회고\n\n처음 제어, 비제어 컴포넌트라는 용어를 들었을 때 아무생각도 들지 않았고 단순히 `state`사용과 `ref`사용 이정도로 끝냈었다.\n\n생각해 보면, 사용자의 정보를 얻고 유효성 검사를 했을 때 무조건 `state`를 사용해서 관리를 했고, 무한 스크롤 같은 UI를 구현할 때는 `ref`로 구현을 했었다.\n\n무의식 적으로 이렇게 하는게 편하고, 그렇게 했으니까? 이런 생각들로 구현을 했었는데,\n\n이제는 좀 더 내가 왜 이렇게 구현했는지, 의미를 알 수 있고, `\u003cInput\u003e`으로 입력된 데이터를 처리할 때, 어떤 방식이 좀 더 효율적인지 알게 되었다.\n\n아직도 부족하지만, 나의 코드가 어떤 의미이고, 왜 이렇게 했는지 조금은 설명이 더 할 수 있을 것 같다.\n\n#### 참고 자료\n\n- https://ko.legacy.reactjs.org/docs/forms.html#controlled-components\n- https://goshacmd.com/controlled-vs-uncontrolled-inputs-react/\n","title":"Controlled 컴포넌트와 UnControlled 컴포넌트 차이점","date":"2023년 4월 12일","description":"React에서 Controlled 컴포넌트와 UnControlled 컴포넌트의 차이점을 알아보자","thumbnail":"","category":"React"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"Controlled-컴포넌트와 UnCotrolled-컴포넌트의-차이점"},"buildId":"HstNFDYMYBk7yzRF4J0tt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>